import wpilib._wpilib
import typing
import ADXL345_I2C
import ADXL345_SPI
import ADXL362
import AddressableLED
import Counter
import Direction
import DistanceUnit
import DoubleSolenoid
import DriverStation
import Encoder
import EncodingType
import Hand
import I2C
import IndexingType
import InterruptableSensorBase
import Mode
import PWM
import Parity
import Port
import Range
import Relay
import SPI
import SerialPort
import StopBits
import Ultrasonic
import _pyntcore._ntcore
import hal._wpiHal
import logging
import wpilib.interfaces._interfaces
import wpilib.interfaces._interfaces.Accelerometer
import wpilib.interfaces._interfaces.CounterBase
import wpilib.interfaces._interfaces.GenericHID
import wpimath.geometry._geometry
import wpimath.trajectory._trajectory

__all__ = [
    "ADXL345_I2C",
    "ADXL345_SPI",
    "ADXL362",
    "ADXRS450_Gyro",
    "AddressableLED",
    "AnalogAccelerometer",
    "AnalogEncoder",
    "AnalogGyro",
    "AnalogInput",
    "AnalogOutput",
    "AnalogPotentiometer",
    "AnalogTrigger",
    "AnalogTriggerOutput",
    "AnalogTriggerType",
    "BuiltInAccelerometer",
    "CAN",
    "CANData",
    "CANStatus",
    "Color",
    "Color8Bit",
    "Compressor",
    "Counter",
    "DMC60",
    "DigitalGlitchFilter",
    "DigitalInput",
    "DigitalOutput",
    "DigitalSource",
    "DoubleSolenoid",
    "DriverStation",
    "DutyCycle",
    "DutyCycleEncoder",
    "Encoder",
    "Error",
    "ErrorBase",
    "Field2d",
    "FieldObject2d",
    "GyroBase",
    "I2C",
    "InterruptableSensorBase",
    "IterativeRobot",
    "IterativeRobotBase",
    "Jaguar",
    "Joystick",
    "LiveWindow",
    "MotorSafety",
    "NidecBrushless",
    "Notifier",
    "PWM",
    "PWMSparkMax",
    "PWMSpeedController",
    "PWMTalonFX",
    "PWMTalonSRX",
    "PWMVenom",
    "PWMVictorSPX",
    "PowerDistributionPanel",
    "Preferences",
    "Relay",
    "RobotBase",
    "RobotController",
    "RobotState",
    "SD540",
    "SPI",
    "Sendable",
    "SendableBase",
    "SendableBuilder",
    "SendableBuilderImpl",
    "SendableChooser",
    "SendableChooserBase",
    "SendableRegistry",
    "SensorUtil",
    "SerialPort",
    "Servo",
    "SlewRateLimiter",
    "SmartDashboard",
    "Solenoid",
    "SolenoidBase",
    "Spark",
    "SpeedControllerGroup",
    "Talon",
    "TimedRobot",
    "Timer",
    "Tracer",
    "Ultrasonic",
    "Victor",
    "VictorSP",
    "Watchdog",
    "XboxController",
    "getCurrentThreadPriority",
    "getTime",
    "setCurrentThreadPriority",
    "wait",
    "wpi_error_s_AnalogTriggerLimitOrderError",
    "wpi_error_s_AnalogTriggerPulseOutputError",
    "wpi_error_s_BadJoystickAxis",
    "wpi_error_s_BadJoystickIndex",
    "wpi_error_s_CameraServerError",
    "wpi_error_s_ChannelIndexOutOfRange",
    "wpi_error_s_CommandIllegalUse",
    "wpi_error_s_CompassManufacturerError",
    "wpi_error_s_CompassTypeError",
    "wpi_error_s_CompressorAlreadyDefined",
    "wpi_error_s_CompressorNonMatching",
    "wpi_error_s_CompressorTaskError",
    "wpi_error_s_CompressorUndefined",
    "wpi_error_s_DashboardDataCollision",
    "wpi_error_s_DashboardDataOverflow",
    "wpi_error_s_DriveUninitialized",
    "wpi_error_s_DriverStationTaskError",
    "wpi_error_s_EnhancedIOMissing",
    "wpi_error_s_EnhancedIOPWMPeriodOutOfRange",
    "wpi_error_s_IncompatibleMode",
    "wpi_error_s_IncompatibleState",
    "wpi_error_s_InconsistentArrayValueAdded",
    "wpi_error_s_IncorrectBatteryChannel",
    "wpi_error_s_InvalidMotorIndex",
    "wpi_error_s_InvalidParameter",
    "wpi_error_s_JaguarMessageNotFound",
    "wpi_error_s_JaguarVersionError",
    "wpi_error_s_LineNotOutput",
    "wpi_error_s_LoopTimingError",
    "wpi_error_s_MismatchedComplexTypeClose",
    "wpi_error_s_ModuleIndexOutOfRange",
    "wpi_error_s_NetworkTablesBufferFull",
    "wpi_error_s_NetworkTablesCorrupt",
    "wpi_error_s_NetworkTablesReadError",
    "wpi_error_s_NetworkTablesWrongType",
    "wpi_error_s_NoAvailableResources",
    "wpi_error_s_NonBinaryDigitalValue",
    "wpi_error_s_NotAllocated",
    "wpi_error_s_NullParameter",
    "wpi_error_s_ParameterOutOfRange",
    "wpi_error_s_ResourceAlreadyAllocated",
    "wpi_error_s_SPIClockRateTooLow",
    "wpi_error_s_SPIReadNoData",
    "wpi_error_s_SPIReadNoMISO",
    "wpi_error_s_SPIWriteNoMOSI",
    "wpi_error_s_SampleRateTooHigh",
    "wpi_error_s_SmartDashboardMissingKey",
    "wpi_error_s_TaskDeletedError",
    "wpi_error_s_TaskError",
    "wpi_error_s_TaskIDError",
    "wpi_error_s_TaskMemoryError",
    "wpi_error_s_TaskOptionsError",
    "wpi_error_s_TaskPriorityError",
    "wpi_error_s_Timeout",
    "wpi_error_s_UnsupportedInSimulation",
    "wpi_error_s_VoltageOutOfRange",
    "wpi_error_value_AnalogTriggerLimitOrderError",
    "wpi_error_value_AnalogTriggerPulseOutputError",
    "wpi_error_value_BadJoystickAxis",
    "wpi_error_value_BadJoystickIndex",
    "wpi_error_value_CameraServerError",
    "wpi_error_value_ChannelIndexOutOfRange",
    "wpi_error_value_CommandIllegalUse",
    "wpi_error_value_CompassManufacturerError",
    "wpi_error_value_CompassTypeError",
    "wpi_error_value_CompressorAlreadyDefined",
    "wpi_error_value_CompressorNonMatching",
    "wpi_error_value_CompressorTaskError",
    "wpi_error_value_CompressorUndefined",
    "wpi_error_value_DashboardDataCollision",
    "wpi_error_value_DashboardDataOverflow",
    "wpi_error_value_DriveUninitialized",
    "wpi_error_value_DriverStationTaskError",
    "wpi_error_value_EnhancedIOMissing",
    "wpi_error_value_EnhancedIOPWMPeriodOutOfRange",
    "wpi_error_value_IncompatibleMode",
    "wpi_error_value_IncompatibleState",
    "wpi_error_value_InconsistentArrayValueAdded",
    "wpi_error_value_IncorrectBatteryChannel",
    "wpi_error_value_InvalidMotorIndex",
    "wpi_error_value_InvalidParameter",
    "wpi_error_value_JaguarMessageNotFound",
    "wpi_error_value_JaguarVersionError",
    "wpi_error_value_LineNotOutput",
    "wpi_error_value_LoopTimingError",
    "wpi_error_value_MismatchedComplexTypeClose",
    "wpi_error_value_ModuleIndexOutOfRange",
    "wpi_error_value_NetworkTablesBufferFull",
    "wpi_error_value_NetworkTablesCorrupt",
    "wpi_error_value_NetworkTablesReadError",
    "wpi_error_value_NetworkTablesWrongType",
    "wpi_error_value_NoAvailableResources",
    "wpi_error_value_NonBinaryDigitalValue",
    "wpi_error_value_NotAllocated",
    "wpi_error_value_NullParameter",
    "wpi_error_value_ParameterOutOfRange",
    "wpi_error_value_ResourceAlreadyAllocated",
    "wpi_error_value_SPIClockRateTooLow",
    "wpi_error_value_SPIReadNoData",
    "wpi_error_value_SPIReadNoMISO",
    "wpi_error_value_SPIWriteNoMOSI",
    "wpi_error_value_SampleRateTooHigh",
    "wpi_error_value_SmartDashboardMissingKey",
    "wpi_error_value_TaskDeletedError",
    "wpi_error_value_TaskError",
    "wpi_error_value_TaskIDError",
    "wpi_error_value_TaskMemoryError",
    "wpi_error_value_TaskOptionsError",
    "wpi_error_value_TaskPriorityError",
    "wpi_error_value_Timeout",
    "wpi_error_value_UnsupportedInSimulation",
    "wpi_error_value_VoltageOutOfRange"
]


class ErrorBase():
    """
    Base class for most objects.

    ErrorBase is the base class for most objects since it holds the generated
    error for that object. In addition, there is a single instance of a global
    error object.
    """
    def __init__(self) -> None: ...
    def clearError(self) -> None: 
        """
        Clear the current error information associated with this sensor.
        """
    def clearGlobalErrors(self) -> None: 
        """
        Clear global errors.
        """
    def cloneError(self, rhs: ErrorBase) -> None: ...
    def getError(self) -> Error: 
        """
        Retrieve the current error.

        Get the current error information associated with this sensor.

        Retrieve the current error.

        Get the current error information associated with this sensor.
        """
    @staticmethod
    def getGlobalError() -> Error: 
        """
        Retrieve the last global error.
        """
    @staticmethod
    def getGlobalErrors() -> typing.List[Error]: 
        """
        Retrieve all global errors.
        """
    def setErrnoError(self, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: 
        """
        Set error information associated with a C library call that set an
        error to the "errno" global variable.

        :param contextMessage: A custom message from the code that set the error.
        :param filename:       Filename of the error source
        :param function:       Function of the error source
        :param lineNumber:     Line number of the error source
        """
    def setError(self, code: int, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: 
        """
        Set the current error information associated with this sensor.

        :param code:           The error code
        :param contextMessage: A custom message from the code that set the error.
        :param filename:       Filename of the error source
        :param function:       Function of the error source
        :param lineNumber:     Line number of the error source
        """
    def setErrorRange(self, code: int, minRange: int, maxRange: int, requestedValue: int, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: 
        """
        Set the current error information associated with this sensor.
        Range versions use for initialization code.

        :param code:           The error code
        :param minRange:       The minimum allowed allocation range
        :param maxRange:       The maximum allowed allocation range
        :param requestedValue: The requested value to allocate
        :param contextMessage: A custom message from the code that set the error.
        :param filename:       Filename of the error source
        :param function:       Function of the error source
        :param lineNumber:     Line number of the error source
        """
    @staticmethod
    def setGlobalError(code: int, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: ...
    @staticmethod
    def setGlobalWPIError(errorMessage: str, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: ...
    def setImaqError(self, success: int, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: 
        """
        Set the current error information associated from the nivision Imaq
        API.

        :param success:        The return from the function
        :param contextMessage: A custom message from the code that set the error.
        :param filename:       Filename of the error source
        :param function:       Function of the error source
        :param lineNumber:     Line number of the error source
        """
    def setWPIError(self, errorMessage: str, code: int, contextMessage: str, filename: str, function: str, lineNumber: int) -> None: 
        """
        Set the current error information associated with this sensor.

        :param errorMessage:   The error message from WPIErrors.h
        :param contextMessage: A custom message from the code that set the error.
        :param filename:       Filename of the error source
        :param function:       Function of the error source
        :param lineNumber:     Line number of the error source
        """
    def statusIsFatal(self) -> bool: 
        """
        Check if the current error code represents a fatal error.

        :returns: true if the current error is fatal.
        """
    @property
    def _m_error(self) -> Error:
        """
        :type: Error
        """
    pass
class Sendable():
    """
    Interface for Sendable objects.
    """
    def __init__(self) -> None: ...
    def initSendable(self, builder: SendableBuilder) -> None: 
        """
        Initializes this Sendable object.

        :param builder: sendable builder
        """
    pass
class ADXL362(ErrorBase, wpilib.interfaces._interfaces.Accelerometer, Sendable):
    """
    ADXL362 SPI Accelerometer.

    This class allows access to an Analog Devices ADXL362 3-axis accelerometer.
    """
    class AllAxes():
        def __init__(self) -> None: ...
        @property
        def XAxis(self) -> float:
            """
            :type: float
            """
        @XAxis.setter
        def XAxis(self, arg0: float) -> None:
            pass
        @property
        def YAxis(self) -> float:
            """
            :type: float
            """
        @YAxis.setter
        def YAxis(self, arg0: float) -> None:
            pass
        @property
        def ZAxis(self) -> float:
            """
            :type: float
            """
        @ZAxis.setter
        def ZAxis(self, arg0: float) -> None:
            pass
        pass
    class Axes():
        """
        Members:

          kAxis_X

          kAxis_Y

          kAxis_Z
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kAxis_X': <Axes.kAxis_X: 0>, 'kAxis_Y': <Axes.kAxis_Y: 2>, 'kAxis_Z': <Axes.kAxis_Z: 4>}
        kAxis_X: wpilib._wpilib.ADXL362.Axes # value = <Axes.kAxis_X: 0>
        kAxis_Y: wpilib._wpilib.ADXL362.Axes # value = <Axes.kAxis_Y: 2>
        kAxis_Z: wpilib._wpilib.ADXL362.Axes # value = <Axes.kAxis_Z: 4>
        pass
    @typing.overload
    def __init__(self, port: SPI.Port, range: wpilib.interfaces._interfaces.Accelerometer.Range = Range.kRange_2G) -> None: 
        """
        Constructor.  Uses the onboard CS1.

        :param range: The range (+ or -) that the accelerometer will measure.

        Constructor.

        :param port:  The SPI port the accelerometer is attached to
        :param range: The range (+ or -) that the accelerometer will measure.
        """
    @typing.overload
    def __init__(self, range: wpilib.interfaces._interfaces.Accelerometer.Range = Range.kRange_2G) -> None: ...
    def getAcceleration(self, axis: ADXL362.Axes) -> float: 
        """
        Get the acceleration of one axis in Gs.

        :param axis: The axis to read from.

        :returns: Acceleration of the ADXL362 in Gs.
        """
    def getAccelerations(self) -> ADXL362.AllAxes: 
        """
        Get the acceleration of all axes in Gs.

        :returns: An object containing the acceleration measured on each axis of the
                  ADXL362 in Gs.
        """
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setRange(self, range: wpilib.interfaces._interfaces.Accelerometer.Range) -> None: ...
    pass
class GyroBase(wpilib.interfaces._interfaces.Gyro, ErrorBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    GyroBase is the common base class for Gyro implementations such as
    AnalogGyro.
    """
    def __init__(self) -> None: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidGet(self) -> float: 
        """
        Get the PIDOutput for the PIDSource base object. Can be set to return
        angle or rate using SetPIDSourceType(). Defaults to angle.

        :returns: The PIDOutput (angle or rate, defaults to angle)
        """
    pass
class AddressableLED(ErrorBase):
    """
    A class for driving addressable LEDs, such as WS2812s and NeoPixels.

    Only 1 LED driver is currently supported by the roboRIO.
    """
    class LEDData():
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, r: int, g: int, b: int) -> None: ...
        def setHSV(self, h: int, s: int, v: int) -> None: 
            """
            A helper method to set all values of the LED.

            :param h: the h value [0-180]
            :param s: the s value [0-255]
            :param v: the v value [0-255]
            """
        @typing.overload
        def setLED(self, color: Color) -> None: ...
        @typing.overload
        def setLED(self, color: Color8Bit) -> None: ...
        def setRGB(self, r: int, g: int, b: int) -> None: 
            """
            A helper method to set all values of the LED.

            :param r: the r value [0-255]
            :param g: the g value [0-255]
            :param b: the b value [0-255]
            """
        pass
    def __init__(self, port: int) -> None: 
        """
        Constructs a new driver for a specific port.

        :param port: the output port to use (Must be a PWM header)
        """
    def setBitTiming(self, lowTime0: nanoseconds, highTime0: nanoseconds, lowTime1: nanoseconds, highTime1: nanoseconds) -> None: 
        """
        Sets the bit timing.

        By default, the driver is set up to drive WS2812s, so nothing needs to
        be set for those.

        :param lowTime0:  low time for 0 bit
        :param highTime0: high time for 0 bit
        :param lowTime1:  low time for 1 bit
        :param highTime1: high time for 1 bit
        """
    def setData(self, ledData: typing.List[AddressableLED.LEDData]) -> None: 
        """
        Sets the led output data.

        If the output is enabled, this will start writing the next data cycle.
        It is safe to call, even while output is enabled.

        :param ledData: the buffer to write
        """
    def setLength(self, length: int) -> None: 
        """
        Sets the length of the LED strip.

        Calling this is an expensive call, so its best to call it once, then
        just update data.

        The max length is 5460 LEDs.

        :param length: the strip length
        """
    def setSyncTime(self, syncTime: microseconds) -> None: 
        """
        Sets the sync time.

        The sync time is the time to hold output so LEDs enable. Default set for
        WS2812.

        :param syncTimeMicroSeconds: the sync time
        """
    def start(self) -> None: 
        """
        Starts the output.

        The output writes continuously.
        """
    def stop(self) -> None: 
        """
        Stops the output.
        """
    pass
class AnalogAccelerometer(ErrorBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Handle operation of an analog accelerometer.

    The accelerometer reads acceleration directly through the sensor. Many
    sensors have multiple axis and can be treated as multiple devices. Each is
    calibrated by finding the center value over a period of time.
    """
    @typing.overload
    def __init__(self, channel: AnalogInput) -> None: 
        """
        Create a new instance of an accelerometer.

        The constructor allocates desired analog input.

        :param channel: The channel number for the analog input the accelerometer is
                        connected to

        Create a new instance of Accelerometer from an existing AnalogInput.

        Make a new instance of accelerometer given an AnalogInput. This is
        particularly useful if the port is going to be read as an analog channel as
        well as through the Accelerometer class.

        :param channel: The existing AnalogInput object for the analog input the
                        accelerometer is connected to
        """
    @typing.overload
    def __init__(self, channel: int) -> None: ...
    def getAcceleration(self) -> float: 
        """
        Return the acceleration in Gs.

        The acceleration is returned units of Gs.

        :returns: The current acceleration of the sensor in Gs.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidGet(self) -> float: 
        """
        Get the Acceleration for the PID Source parent.

        :returns: The current acceleration in Gs.
        """
    def setSensitivity(self, sensitivity: float) -> None: 
        """
        Set the accelerometer sensitivity.

        This sets the sensitivity of the accelerometer used for calculating the
        acceleration. The sensitivity varies by accelerometer model. There are
        constants defined for various models.

        :param sensitivity: The sensitivity of accelerometer in Volts per G.
        """
    def setZero(self, zero: float) -> None: 
        """
        Set the voltage that corresponds to 0 G.

        The zero G voltage varies by accelerometer model. There are constants
        defined for various models.

        :param zero: The zero G voltage.
        """
    pass
class AnalogEncoder(ErrorBase, Sendable):
    """
    Class for supporting continuous analog encoders, such as the US Digital MA3.
    """
    @typing.overload
    def __init__(self, analogInput: AnalogInput) -> None: 
        """
        Construct a new AnalogEncoder attached to a specific AnalogIn channel.

        :param channel: the analog input channel to attach to

        Construct a new AnalogEncoder attached to a specific AnalogInput.

        :param analogInput: the analog input to attach to
        """
    @typing.overload
    def __init__(self, channel: int) -> None: ...
    def get(self) -> turns: 
        """
        Get the encoder value since the last reset.

        This is reported in rotations since the last reset.

        :returns: the encoder value in rotations
        """
    def getChannel(self) -> int: 
        """
        Get the channel number.

        :returns: The channel number.
        """
    def getDistance(self) -> float: 
        """
        Get the distance the sensor has driven since the last reset as scaled by
        the value from SetDistancePerRotation.

        :returns: The distance driven since the last reset
        """
    def getDistancePerRotation(self) -> float: 
        """
        Get the distance per rotation for this encoder.

        :returns: The scale factor that will be used to convert rotation to useful
                  units.
        """
    def getPositionOffset(self) -> float: 
        """
        Get the offset of position relative to the last reset.

        :returns: the position offset
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def reset(self) -> None: 
        """
        Reset the Encoder distance to zero.
        """
    def setDistancePerRotation(self, distancePerRotation: float) -> None: 
        """
        Set the distance per rotation of the encoder. This sets the multiplier used
        to determine the distance driven based on the rotation value from the
        encoder. Set this value based on the how far the mechanism travels in 1
        rotation of the encoder, and factor in gearing reductions following the
        encoder shaft. This distance can be in any units you like, linear or
        angular.

        :param distancePerRotation: the distance per rotation of the encoder
        """
    pass
class AnalogGyro(GyroBase, wpilib.interfaces._interfaces.Gyro, ErrorBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Use a rate gyro to return the robots heading relative to a starting position.
    The Gyro class tracks the robots heading based on the starting position. As
    the robot rotates the new heading is computed by integrating the rate of
    rotation returned by the sensor. When the class is instantiated, it does a
    short calibration routine where it samples the gyro while at rest to
    determine the default offset. This is subtracted from each sample to
    determine the heading. This gyro class must be used with a channel that is
    assigned one of the Analog accumulators from the FPGA. See AnalogInput for
    the current accumulator assignments.

    This class is for gyro sensors that connect to an analog input.
    """
    @typing.overload
    def __init__(self, channel: AnalogInput) -> None: 
        """
        Gyro constructor using the Analog Input channel number.

        :param channel: The analog channel the gyro is connected to. Gyros can only
                        be used on on-board Analog Inputs 0-1.

        Gyro constructor with a precreated AnalogInput object.

        Use this constructor when the analog channel needs to be shared.
        This object will not clean up the AnalogInput object when using this
        constructor.

        :param channel: A pointer to the AnalogInput object that the gyro is
                        connected to.

        Gyro constructor using the Analog Input channel number with parameters for
        presetting the center and offset values. Bypasses calibration.

        :param channel: The analog channel the gyro is connected to. Gyros can only
                        be used on on-board Analog Inputs 0-1.
        :param center:  Preset uncalibrated value to use as the accumulator center
                        value.
        :param offset:  Preset uncalibrated value to use as the gyro offset.

        Gyro constructor with a precreated AnalogInput object and calibrated
        parameters.

        Use this constructor when the analog channel needs to be shared.
        This object will not clean up the AnalogInput object when using this
        constructor.

        :param channel: A pointer to the AnalogInput object that the gyro is
                        connected to.
        :param center:  Preset uncalibrated value to use as the accumulator center
                        value.
        :param offset:  Preset uncalibrated value to use as the gyro offset.
        """
    @typing.overload
    def __init__(self, channel: AnalogInput, center: int, offset: float) -> None: ...
    @typing.overload
    def __init__(self, channel: int) -> None: ...
    @typing.overload
    def __init__(self, channel: int, center: int, offset: float) -> None: ...
    def calibrate(self) -> None: ...
    def getAnalogInput(self) -> AnalogInput: 
        """
        Gets the analog input for the gyro.

        :returns: AnalogInput
        """
    def getAngle(self) -> float: 
        """
        Return the actual angle in degrees that the robot is currently facing.

        The angle is based on the current accumulator value corrected by the
        oversampling rate, the gyro type and the A/D calibration values. The angle
        is continuous, that is it will continue from 360->361 degrees. This allows
        algorithms that wouldn't want to see a discontinuity in the gyro output as
        it sweeps from 360 to 0 on the second time around.

        :returns: The current heading of the robot in degrees. This heading is based
                  on integration of the returned rate from the gyro.
        """
    def getCenter(self) -> int: 
        """
        Return the gyro center value. If run after calibration,
        the center value can be used as a preset later.

        :returns: the current center value
        """
    def getOffset(self) -> float: 
        """
        Return the gyro offset value. If run after calibration,
        the offset value can be used as a preset later.

        :returns: the current offset value
        """
    def getRate(self) -> float: 
        """
        Return the rate of rotation of the gyro

        The rate is based on the most recent reading of the gyro analog value

        :returns: the current rate in degrees per second
        """
    def initGyro(self) -> None: 
        """
        Initialize the gyro.

        Calibration is handled by Calibrate().
        """
    def reset(self) -> None: 
        """
        Reset the gyro.

        Resets the gyro to a heading of zero. This can be used if there is
        significant drift in the gyro and it needs to be recalibrated after it has
        been running.
        """
    def setDeadband(self, volts: float) -> None: 
        """
        Set the size of the neutral zone.

        Any voltage from the gyro less than this amount from the center is
        considered stationary.  Setting a deadband will decrease the amount of
        drift when the gyro isn't rotating, but will make it less accurate.

        :param volts: The size of the deadband in volts
        """
    def setSensitivity(self, voltsPerDegreePerSecond: float) -> None: 
        """
        Set the gyro sensitivity.

        This takes the number of volts/degree/second sensitivity of the gyro and
        uses it in subsequent calculations to allow the code to work with multiple
        gyros. This value is typically found in the gyro datasheet.

        :param voltsPerDegreePerSecond: The sensitivity in Volts/degree/second
        """
    @property
    def _m_analog(self) -> AnalogInput:
        """
        :type: AnalogInput
        """
    kAverageBits = 0
    kCalibrationSampleTime = 5.0
    kDefaultVoltsPerDegreePerSecond = 0.007
    kOversampleBits = 10
    kSamplesPerSecond = 50.0
    pass
class AnalogInput(ErrorBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Analog input class.

    Connected to each analog channel is an averaging and oversampling engine.
    This engine accumulates the specified ( by SetAverageBits() and
    SetOversampleBits() ) number of samples before returning a new value. This is
    not a sliding window average. The only difference between the oversampled
    samples and the averaged samples is that the oversampled samples are simply
    accumulated effectively increasing the resolution, while the averaged samples
    are divided by the number of samples to retain the resolution, but get more
    stable values.
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct an analog input.

        :param channel: The channel number on the roboRIO to represent. 0-3 are
                        on-board 4-7 are on the MXP port.
        """
    def __repr__(self) -> str: ...
    def getAccumulatorCount(self) -> int: 
        """
        Read the number of accumulated values.

        Read the count of the accumulated values since the accumulator was last
        Reset().

        :returns: The number of times samples from the channel were accumulated.
        """
    def getAccumulatorOutput(self) -> typing.Tuple[int, int]: 
        """
        Read the accumulated value and the number of accumulated values atomically.

        This function reads the value and count from the FPGA atomically.
        This can be used for averaging.

        :param value: Reference to the 64-bit accumulated output.
        :param count: Reference to the number of accumulation cycles.
        """
    def getAccumulatorValue(self) -> int: 
        """
        Read the accumulated value.

        Read the value that has been accumulating.
        The accumulator is attached after the oversample and average engine.

        :returns: The 64-bit value accumulated since the last Reset().
        """
    def getAverageBits(self) -> int: 
        """
        Get the number of averaging bits previously configured.

        This gets the number of averaging bits from the FPGA. The actual number of
        averaged samples is 2^bits. The averaging is done automatically in the
        FPGA.

        :returns: Number of bits of averaging previously configured.
        """
    def getAverageValue(self) -> int: 
        """
        Get a sample from the output of the oversample and average engine for this
        channel.

        The sample is 12-bit + the bits configured in SetOversampleBits().
        The value configured in SetAverageBits() will cause this value to be
        averaged 2**bits number of samples.

        This is not a sliding window. The sample will not change until
        2**(OversampleBits + AverageBits) samples have been acquired from the
        module on this channel.

        Use GetAverageVoltage() to get the analog value in calibrated units.

        :returns: A sample from the oversample and average engine for this channel.
        """
    def getAverageVoltage(self) -> float: 
        """
        Get a scaled sample from the output of the oversample and average engine
        for this channel.

        The value is scaled to units of Volts using the calibrated scaling data
        from GetLSBWeight() and GetOffset().

        Using oversampling will cause this value to be higher resolution, but it
        will update more slowly.

        Using averaging will cause this value to be more stable, but it will update
        more slowly.

        :returns: A scaled sample from the output of the oversample and average
                  engine for this channel.
        """
    def getChannel(self) -> int: 
        """
        Get the channel number.

        :returns: The channel number.
        """
    def getLSBWeight(self) -> int: 
        """
        Get the factory scaling least significant bit weight constant.

        Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)

        :returns: Least significant bit weight.
        """
    def getOffset(self) -> int: 
        """
        Get the factory scaling offset constant.

        Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)

        :returns: Offset constant.
        """
    def getOversampleBits(self) -> int: 
        """
        Get the number of oversample bits previously configured.

        This gets the number of oversample bits from the FPGA. The actual number of
        oversampled values is 2^bits. The oversampling is done automatically in the
        FPGA.

        :returns: Number of bits of oversampling previously configured.
        """
    @staticmethod
    def getSampleRate() -> float: 
        """
        Get the current sample rate for all channels

        :returns: Sample rate.
        """
    def getValue(self) -> int: 
        """
        Get a sample straight from this channel.

        The sample is a 12-bit value representing the 0V to 5V range of the A/D
        converter in the module.  The units are in A/D converter codes.  Use
        GetVoltage() to get the analog value in calibrated units.

        :returns: A sample straight from this channel.
        """
    def getVoltage(self) -> float: 
        """
        Get a scaled sample straight from this channel.

        The value is scaled to units of Volts using the calibrated scaling data
        from GetLSBWeight() and GetOffset().

        :returns: A scaled sample straight from this channel.
        """
    def initAccumulator(self) -> None: 
        """
        Initialize the accumulator.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isAccumulatorChannel(self) -> bool: 
        """
        Is the channel attached to an accumulator.

        :returns: The analog input is attached to an accumulator.
        """
    def pidGet(self) -> float: 
        """
        Get the Average value for the PID Source base object.

        :returns: The average voltage.
        """
    def resetAccumulator(self) -> None: 
        """
        Resets the accumulator to the initial value.
        """
    def setAccumulatorCenter(self, center: int) -> None: 
        """
        Set the center value of the accumulator.

        The center value is subtracted from each A/D value before it is added to
        the accumulator. This is used for the center value of devices like gyros
        and accelerometers to take the device offset into account when integrating.

        This center value is based on the output of the oversampled and averaged
        source from the accumulator channel. Because of this, any non-zero
        oversample bits will affect the size of the value for this field.
        """
    def setAccumulatorDeadband(self, deadband: int) -> None: 
        """
        Set the accumulator's deadband.
        """
    def setAccumulatorInitialValue(self, value: int) -> None: 
        """
        Set an initial value for the accumulator.

        This will be added to all values returned to the user.

        :param initialValue: The value that the accumulator should start from when
                             reset.
        """
    def setAverageBits(self, bits: int) -> None: 
        """
        Set the number of averaging bits.

        This sets the number of averaging bits. The actual number of averaged
        samples is 2^bits.

        Use averaging to improve the stability of your measurement at the expense
        of sampling rate. The averaging is done automatically in the FPGA.

        :param bits: Number of bits of averaging.
        """
    def setOversampleBits(self, bits: int) -> None: 
        """
        Set the number of oversample bits.

        This sets the number of oversample bits. The actual number of oversampled
        values is 2^bits. Use oversampling to improve the resolution of your
        measurements at the expense of sampling rate. The oversampling is done
        automatically in the FPGA.

        :param bits: Number of bits of oversampling.
        """
    @staticmethod
    def setSampleRate(samplesPerSecond: float) -> None: 
        """
        Set the sample rate per channel for all analog channels.

        The maximum rate is 500kS/s divided by the number of channels in use.
        This is 62500 samples/s per channel.

        :param samplesPerSecond: The number of samples per second.
        """
    def setSimDevice(self, device: int) -> None: 
        """
        Indicates this input is used by a simulated device.

        :param device: simulated device handle
        """
    kAccumulatorModuleNumber = 1
    kAccumulatorNumChannels = 2
    pass
class AnalogOutput(ErrorBase, Sendable):
    """
    MXP analog output class.
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct an analog output on the given channel.

        All analog outputs are located on the MXP port.

        :param channel: The channel number on the roboRIO to represent.
        """
    def __repr__(self) -> str: ...
    def getChannel(self) -> int: 
        """
        Get the channel of this AnalogOutput.
        """
    def getVoltage(self) -> float: 
        """
        Get the voltage of the analog output

        :returns: The value in Volts, from 0.0 to +5.0
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setVoltage(self, voltage: float) -> None: 
        """
        Set the value of the analog output.

        :param voltage: The output value in Volts, from 0.0 to +5.0
        """
    @property
    def _m_channel(self) -> int:
        """
        :type: int
        """
    @_m_channel.setter
    def _m_channel(self, arg0: int) -> None:
        pass
    pass
class AnalogPotentiometer(ErrorBase, wpilib.interfaces._interfaces.Potentiometer, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Class for reading analog potentiometers. Analog potentiometers read in an
    analog voltage that corresponds to a position. The position is in whichever
    units you choose, by way of the scaling and offset constants passed to the
    constructor.
    """
    @typing.overload
    def __init__(self, channel: int, fullRange: float = 1.0, offset: float = 0.0) -> None: 
        """
        Construct an Analog Potentiometer object from a channel number.

        Use the fullRange and offset values so that the output produces meaningful
        values. I.E: you have a 270 degree potentiometer and you want the output to
        be degrees with the halfway point as 0 degrees. The fullRange value is
        270.0 degrees and the offset is -135.0 since the halfway point after
        scaling is 135 degrees.

        This will calculate the result from the fullRange times the fraction of the
        supply voltage, plus the offset.

        :param channel:   The Analog Input channel number on the roboRIO the
                          potentiometer is plugged into. 0-3 are on-board and 4-7
                          are on the MXP port.
        :param fullRange: The value (in desired units) representing the full
                          0-5V range of the input.
        :param offset:    The value (in desired units) representing the
                          angular output at 0V.

        Construct an Analog Potentiometer object from an existing Analog Input
        pointer.

        Use the fullRange and offset values so that the output produces meaningful
        values. I.E: you have a 270 degree potentiometer and you want the output to
        be degrees with the halfway point as 0 degrees. The fullRange value is
        270.0 degrees and the offset is -135.0 since the halfway point after
        scaling is 135 degrees.

        This will calculate the result from the fullRange times the fraction of the
        supply voltage, plus the offset.

        :param channel:   The existing Analog Input pointer
        :param fullRange: The value (in desired units) representing the full
                          0-5V range of the input.
        :param offset:    The value (in desired units) representing the
                          angular output at 0V.
        """
    @typing.overload
    def __init__(self, input: AnalogInput, fullRange: float = 1.0, offset: float = 0.0) -> None: ...
    def get(self) -> float: 
        """
        Get the current reading of the potentiometer.

        :returns: The current position of the potentiometer (in the units used for
                  fullRange and offset).
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidGet(self) -> float: 
        """
        Implement the PIDSource interface.

        :returns: The current reading.
        """
    pass
class AnalogTrigger(ErrorBase, Sendable):
    @typing.overload
    def __init__(self, channel: AnalogInput) -> None: 
        """
        Constructor for an analog trigger given a channel number.

        :param channel: The channel number on the roboRIO to represent. 0-3 are
                        on-board 4-7 are on the MXP port.

        Construct an analog trigger given an analog input.

        This should be used in the case of sharing an analog channel between the
        trigger and an analog input object.

        :param channel: The pointer to the existing AnalogInput object

        Construct an analog trigger given a duty cycle input.

        :param channel: The pointer to the existing DutyCycle object
        """
    @typing.overload
    def __init__(self, channel: int) -> None: ...
    @typing.overload
    def __init__(self, dutyCycle: DutyCycle) -> None: ...
    def createOutput(self, type: AnalogTriggerType) -> AnalogTriggerOutput: 
        """
        Creates an AnalogTriggerOutput object.

        Gets an output object that can be used for routing. Caller is responsible
        for deleting the AnalogTriggerOutput object.

        :param type: An enum of the type of output object to create.

        :returns: A pointer to a new AnalogTriggerOutput object.
        """
    def getInWindow(self) -> bool: 
        """
        Return the InWindow output of the analog trigger.

        True if the analog input is between the upper and lower limits.

        :returns: True if the analog input is between the upper and lower limits.
        """
    def getIndex(self) -> int: 
        """
        Return the index of the analog trigger.

        This is the FPGA index of this analog trigger instance.

        :returns: The index of the analog trigger.
        """
    def getTriggerState(self) -> bool: 
        """
        Return the TriggerState output of the analog trigger.

        True if above upper limit.
        False if below lower limit.
        If in Hysteresis, maintain previous state.

        :returns: True if above upper limit. False if below lower limit. If in
                  Hysteresis, maintain previous state.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setAveraged(self, useAveragedValue: bool) -> None: 
        """
        Configure the analog trigger to use the averaged vs. raw values.

        If the value is true, then the averaged value is selected for the analog
        trigger, otherwise the immediate value is used.

        :param useAveragedValue: If true, use the Averaged value, otherwise use the
                                 instantaneous reading
        """
    def setFiltered(self, useFilteredValue: bool) -> None: 
        """
        Configure the analog trigger to use a filtered value.

        The analog trigger will operate with a 3 point average rejection filter.
        This is designed to help with 360 degree pot applications for the period
        where the pot crosses through zero.

        :param useFilteredValue: If true, use the 3 point rejection filter,
                                 otherwise use the unfiltered value
        """
    def setLimitsDutyCycle(self, lower: float, upper: float) -> None: 
        """
        Set the upper and lower duty cycle limits of the analog trigger.

        The limits are given as floating point values between 0 and 1.

        :param lower: The lower limit of the trigger in percentage.
        :param upper: The upper limit of the trigger in percentage.
        """
    def setLimitsRaw(self, lower: int, upper: int) -> None: 
        """
        Set the upper and lower limits of the analog trigger.

        The limits are given in ADC codes.  If oversampling is used, the units must
        be scaled appropriately.

        :param lower: The lower limit of the trigger in ADC codes (12-bit values).
        :param upper: The upper limit of the trigger in ADC codes (12-bit values).
        """
    def setLimitsVoltage(self, lower: float, upper: float) -> None: 
        """
        Set the upper and lower limits of the analog trigger.

        The limits are given as floating point voltage values.

        :param lower: The lower limit of the trigger in Volts.
        :param upper: The upper limit of the trigger in Volts.
        """
    pass
class InterruptableSensorBase(ErrorBase):
    class WaitResult():
        """
        Members:

          kTimeout

          kRisingEdge

          kFallingEdge

          kBoth
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kTimeout': <WaitResult.kTimeout: 0>, 'kRisingEdge': <WaitResult.kRisingEdge: 1>, 'kFallingEdge': <WaitResult.kFallingEdge: 256>, 'kBoth': <WaitResult.kBoth: 257>}
        kBoth: wpilib._wpilib.InterruptableSensorBase.WaitResult # value = <WaitResult.kBoth: 257>
        kFallingEdge: wpilib._wpilib.InterruptableSensorBase.WaitResult # value = <WaitResult.kFallingEdge: 256>
        kRisingEdge: wpilib._wpilib.InterruptableSensorBase.WaitResult # value = <WaitResult.kRisingEdge: 1>
        kTimeout: wpilib._wpilib.InterruptableSensorBase.WaitResult # value = <WaitResult.kTimeout: 0>
        pass
    def __init__(self) -> None: ...
    def _allocateInterrupts(self, watcher: bool) -> None: ...
    def cancelInterrupts(self) -> None: 
        """
        Cancel interrupts on this device.

        This deallocates all the chipobject structures and disables any interrupts.
        """
    def disableInterrupts(self) -> None: 
        """
        Disable Interrupts without without deallocating structures.
        """
    def enableInterrupts(self) -> None: 
        """
        Enable interrupts to occur on this input.

        Interrupts are disabled when the RequestInterrupt call is made. This gives
        time to do the setup of the other options before starting to field
        interrupts.
        """
    def getAnalogTriggerTypeForRouting(self) -> AnalogTriggerType: ...
    def getPortHandleForRouting(self) -> int: ...
    def readFallingTimestamp(self) -> float: 
        """
        Return the timestamp for the falling interrupt that occurred most recently.

        This is in the same time domain as GetClock().
        The falling-edge interrupt should be enabled with
        :meth:`.DigitalInput.SetUpSourceEdge`

        :returns: Timestamp in seconds since boot.
        """
    def readRisingTimestamp(self) -> float: 
        """
        Return the timestamp for the rising interrupt that occurred most recently.

        This is in the same time domain as GetClock(). The rising-edge interrupt
        should be enabled with SetUpSourceEdge().

        :returns: Timestamp in seconds since boot.
        """
    @typing.overload
    def requestInterrupts(self) -> None: 
        """
        Request one of the 8 interrupts asynchronously on this digital input.

        Request interrupts in asynchronous mode where the user's interrupt handler
        will be called when the interrupt fires. Users that want control over the
        thread priority should use the synchronous method with their own spawned
        thread. The default is interrupt on rising edges only.

        Request one of the 8 interrupts synchronously on this digital input.

        Request interrupts in synchronous mode where the user program will have to
        explicitly wait for the interrupt to occur using WaitForInterrupt.
        The default is interrupt on rising edges only.
        """
    @typing.overload
    def requestInterrupts(self, handler: typing.Callable[[InterruptableSensorBase.WaitResult], None]) -> None: ...
    def setUpSourceEdge(self, risingEdge: bool, fallingEdge: bool) -> None: 
        """
        Set which edge to trigger interrupts on

        :param risingEdge:  true to interrupt on rising edge
        :param fallingEdge: true to interrupt on falling edge
        """
    def waitForInterrupt(self, timeout: float, ignorePrevious: bool = True) -> InterruptableSensorBase.WaitResult: 
        """
        In synchronous mode, wait for the defined interrupt to occur.

        You should **NOT** attempt to read the sensor from another thread while
        waiting for an interrupt. This is not threadsafe, and can cause memory
        corruption

        :param timeout:        Timeout in seconds
        :param ignorePrevious: If true, ignore interrupts that happened before
                               WaitForInterrupt was called.

        :returns: What interrupts fired
        """
    pass
class AnalogTriggerType():
    """
    Members:

      kInWindow

      kState

      kRisingPulse

      kFallingPulse
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    __members__: dict # value = {'kInWindow': <AnalogTriggerType.kInWindow: 0>, 'kState': <AnalogTriggerType.kState: 1>, 'kRisingPulse': <AnalogTriggerType.kRisingPulse: 2>, 'kFallingPulse': <AnalogTriggerType.kFallingPulse: 3>}
    kFallingPulse: wpilib._wpilib.AnalogTriggerType # value = <AnalogTriggerType.kFallingPulse: 3>
    kInWindow: wpilib._wpilib.AnalogTriggerType # value = <AnalogTriggerType.kInWindow: 0>
    kRisingPulse: wpilib._wpilib.AnalogTriggerType # value = <AnalogTriggerType.kRisingPulse: 2>
    kState: wpilib._wpilib.AnalogTriggerType # value = <AnalogTriggerType.kState: 1>
    pass
class BuiltInAccelerometer(ErrorBase, wpilib.interfaces._interfaces.Accelerometer, Sendable):
    """
    Built-in accelerometer.

    This class allows access to the roboRIO's internal accelerometer.
    """
    def __init__(self, range: wpilib.interfaces._interfaces.Accelerometer.Range = Range.kRange_8G) -> None: 
        """
        Constructor.

        :param range: The range the accelerometer will measure
        """
    def getX(self) -> float: 
        """
        :returns: The acceleration of the roboRIO along the X axis in g-forces
        """
    def getY(self) -> float: 
        """
        :returns: The acceleration of the roboRIO along the Y axis in g-forces
        """
    def getZ(self) -> float: 
        """
        :returns: The acceleration of the roboRIO along the Z axis in g-forces
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setRange(self, range: wpilib.interfaces._interfaces.Accelerometer.Range) -> None: 
        """
        Set the measuring range of the accelerometer.

        :param range: The maximum acceleration, positive or negative, that the
                      accelerometer will measure. Not all accelerometers support all
                      ranges.
        """
    pass
class CAN(ErrorBase):
    """
    High level class for interfacing with CAN devices conforming to
    the standard CAN spec.

    No packets that can be sent gets blocked by the RoboRIO, so all methods
    work identically in all robot modes.

    All methods are thread save, however the buffer objects passed in
    by the user need to not be modified for the duration of their calls.
    """
    @typing.overload
    def __init__(self, deviceId: int) -> None: 
        """
        Create a new CAN communication interface with the specific device ID.
        This uses the team manufacturer and device types.
        The device ID is 6 bits (0-63)

        :param deviceId: The device id

        Create a new CAN communication interface with a specific device ID,
        manufacturer and device type. The device ID is 6 bits, the
        manufacturer is 8 bits, and the device type is 5 bits.

        :param deviceId:           The device ID
        :param deviceManufacturer: The device manufacturer
        :param deviceType:         The device type
        """
    @typing.overload
    def __init__(self, deviceId: int, deviceManufacturer: int, deviceType: int) -> None: ...
    def readPacketLatest(self, apiId: int, data: CANData) -> bool: 
        """
        Read a CAN packet. The will continuously return the last packet received,
        without accounting for packet age.

        :param apiId: The API ID to read.
        :param data:  Storage for the received data.

        :returns: True if the data is valid, otherwise false.
        """
    def readPacketNew(self, apiId: int, data: CANData) -> bool: 
        """
        Read a new CAN packet. This will only return properly once per packet
        received. Multiple calls without receiving another packet will return
        false.

        :param apiId: The API ID to read.
        :param data:  Storage for the received data.

        :returns: True if the data is valid, otherwise false.
        """
    def readPacketTimeout(self, apiId: int, timeoutMs: int, data: CANData) -> bool: 
        """
        Read a CAN packet. The will return the last packet received until the
        packet is older then the requested timeout. Then it will return false.

        :param apiId:     The API ID to read.
        :param timeoutMs: The timeout time for the packet
        :param data:      Storage for the received data.

        :returns: True if the data is valid, otherwise false.
        """
    def stopPacketRepeating(self, apiId: int) -> None: 
        """
        Stop a repeating packet with a specific ID. This ID is 10 bits.

        :param apiId: The API ID to stop repeating
        """
    def writePacket(self, data: buffer, apiId: int) -> None: 
        """
        Write a packet to the CAN device with a specific ID. This ID is 10 bits.

        :param data:   The data to write (8 bytes max)
        :param length: The data length to write
        :param apiId:  The API ID to write.
        """
    def writePacketNoError(self, data: int, length: int, apiId: int) -> int: 
        """
        Write a packet to the CAN device with a specific ID. This ID is 10 bits.

        :param data:   The data to write (8 bytes max)
        :param length: The data length to write
        :param apiId:  The API ID to write.
        """
    def writePacketRepeating(self, data: buffer, apiId: int, repeatMs: int) -> None: 
        """
        Write a repeating packet to the CAN device with a specific ID. This ID is
        10 bits. The RoboRIO will automatically repeat the packet at the specified
        interval

        :param data:     The data to write (8 bytes max)
        :param length:   The data length to write
        :param apiId:    The API ID to write.
        :param repeatMs: The period to repeat the packet at.
        """
    def writePacketRepeatingNoError(self, data: int, length: int, apiId: int, repeatMs: int) -> int: 
        """
        Write a repeating packet to the CAN device with a specific ID. This ID is
        10 bits. The RoboRIO will automatically repeat the packet at the specified
        interval

        :param data:     The data to write (8 bytes max)
        :param length:   The data length to write
        :param apiId:    The API ID to write.
        :param repeatMs: The period to repeat the packet at.
        """
    def writeRTRFrame(self, length: int, apiId: int) -> None: 
        """
        Write an RTR frame to the CAN device with a specific ID. This ID is 10
        bits. The length by spec must match what is returned by the responding
        device

        :param length: The length to request (0 to 8)
        :param apiId:  The API ID to write.
        """
    def writeRTRFrameNoError(self, length: int, apiId: int) -> int: 
        """
        Write an RTR frame to the CAN device with a specific ID. This ID is 10
        bits. The length by spec must match what is returned by the responding
        device

        :param length: The length to request (0 to 8)
        :param apiId:  The API ID to write.
        """
    kTeamDeviceType: hal._wpiHal.CANDeviceType # value = <CANDeviceType.kMiscellaneous: 10>
    kTeamManufacturer: hal._wpiHal.CANManufacturer # value = <CANManufacturer.kTeamUse: 8>
    pass
class CANData():
    def __init__(self) -> None: ...
    @property
    def data(self) -> memoryview:
        """
        :type: memoryview
        """
    @property
    def length(self) -> int:
        """
        :type: int
        """
    @length.setter
    def length(self, arg0: int) -> None:
        pass
    @property
    def timestamp(self) -> int:
        """
        :type: int
        """
    @timestamp.setter
    def timestamp(self, arg0: int) -> None:
        pass
    pass
class CANStatus():
    def __init__(self) -> None: ...
    @property
    def busOffCount(self) -> int:
        """
        :type: int
        """
    @busOffCount.setter
    def busOffCount(self, arg0: int) -> None:
        pass
    @property
    def percentBusUtilization(self) -> float:
        """
        :type: float
        """
    @percentBusUtilization.setter
    def percentBusUtilization(self, arg0: float) -> None:
        pass
    @property
    def receiveErrorCount(self) -> int:
        """
        :type: int
        """
    @receiveErrorCount.setter
    def receiveErrorCount(self, arg0: int) -> None:
        pass
    @property
    def transmitErrorCount(self) -> int:
        """
        :type: int
        """
    @transmitErrorCount.setter
    def transmitErrorCount(self, arg0: int) -> None:
        pass
    @property
    def txFullCount(self) -> int:
        """
        :type: int
        """
    @txFullCount.setter
    def txFullCount(self, arg0: int) -> None:
        pass
    pass
class Color():
    """
    Represents colors that can be used with Addressable LEDs.

    Limited to 12 bits of precision.
    """
    def __eq__(self, arg0: Color) -> bool: ...
    def __hash__(self) -> int: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Constructs a Color.

        :param red:   Red value (0-1)
        :param green: Green value (0-1)
        :param blue:  Blue value (0-1)
        """
    @typing.overload
    def __init__(self, red: float, green: float, blue: float) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def fromHSV(h: int, s: int, v: int) -> Color: 
        """
        Creates a Color from HSV values.

        :param h: The h value [0-180]
        :param s: The s value [0-255]
        :param v: The v value [0-255]

        :returns: The color
        """
    @property
    def blue(self) -> float:
        """
        :type: float
        """
    @property
    def green(self) -> float:
        """
        :type: float
        """
    @property
    def red(self) -> float:
        """
        :type: float
        """
    kAliceBlue: wpilib._wpilib.Color # value = Color(red=0.941284, green=0.972534, blue=1.000000)
    kAntiqueWhite: wpilib._wpilib.Color # value = Color(red=0.980347, green=0.921509, blue=0.843140)
    kAqua: wpilib._wpilib.Color # value = Color(red=0.000122, green=1.000000, blue=1.000000)
    kAquamarine: wpilib._wpilib.Color # value = Color(red=0.497925, green=1.000000, blue=0.831421)
    kAzure: wpilib._wpilib.Color # value = Color(red=0.941284, green=1.000000, blue=1.000000)
    kBeige: wpilib._wpilib.Color # value = Color(red=0.960815, green=0.960815, blue=0.862671)
    kBisque: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.894165, blue=0.768677)
    kBlack: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.000122, blue=0.000122)
    kBlanchedAlmond: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.921509, blue=0.803833)
    kBlue: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.000122, blue=1.000000)
    kBlueViolet: wpilib._wpilib.Color # value = Color(red=0.541138, green=0.168579, blue=0.886353)
    kBrown: wpilib._wpilib.Color # value = Color(red=0.647095, green=0.164673, blue=0.164673)
    kBurlywood: wpilib._wpilib.Color # value = Color(red=0.870483, green=0.721558, blue=0.529419)
    kCadetBlue: wpilib._wpilib.Color # value = Color(red=0.372437, green=0.619507, blue=0.627563)
    kChartreuse: wpilib._wpilib.Color # value = Color(red=0.497925, green=1.000000, blue=0.000122)
    kChocolate: wpilib._wpilib.Color # value = Color(red=0.823608, green=0.411743, blue=0.117554)
    kCoral: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.497925, blue=0.313843)
    kCornflowerBlue: wpilib._wpilib.Color # value = Color(red=0.392212, green=0.584351, blue=0.929321)
    kCornsilk: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.972534, blue=0.862671)
    kCrimson: wpilib._wpilib.Color # value = Color(red=0.862671, green=0.078491, blue=0.235229)
    kCyan: wpilib._wpilib.Color # value = Color(red=0.000122, green=1.000000, blue=1.000000)
    kDarkBlue: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.000122, blue=0.545044)
    kDarkCyan: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.545044, blue=0.545044)
    kDarkGoldenrod: wpilib._wpilib.Color # value = Color(red=0.721558, green=0.525513, blue=0.043091)
    kDarkGray: wpilib._wpilib.Color # value = Color(red=0.662720, green=0.662720, blue=0.662720)
    kDarkGreen: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.392212, blue=0.000122)
    kDarkKhaki: wpilib._wpilib.Color # value = Color(red=0.741089, green=0.717651, blue=0.419556)
    kDarkMagenta: wpilib._wpilib.Color # value = Color(red=0.545044, green=0.000122, blue=0.545044)
    kDarkOliveGreen: wpilib._wpilib.Color # value = Color(red=0.333374, green=0.419556, blue=0.184204)
    kDarkOrange: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.548950, blue=0.000122)
    kDarkOrchid: wpilib._wpilib.Color # value = Color(red=0.599976, green=0.196167, blue=0.799927)
    kDarkRed: wpilib._wpilib.Color # value = Color(red=0.545044, green=0.000122, blue=0.000122)
    kDarkSalmon: wpilib._wpilib.Color # value = Color(red=0.913696, green=0.588257, blue=0.478394)
    kDarkSeaGreen: wpilib._wpilib.Color # value = Color(red=0.560669, green=0.737183, blue=0.560669)
    kDarkSlateBlue: wpilib._wpilib.Color # value = Color(red=0.282349, green=0.239136, blue=0.545044)
    kDarkSlateGray: wpilib._wpilib.Color # value = Color(red=0.184204, green=0.309692, blue=0.309692)
    kDarkTurquoise: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.807739, blue=0.819702)
    kDarkViolet: wpilib._wpilib.Color # value = Color(red=0.580444, green=0.000122, blue=0.827515)
    kDeepPink: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.078491, blue=0.576538)
    kDeepSkyBlue: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.748901, blue=1.000000)
    kDenim: wpilib._wpilib.Color # value = Color(red=0.082397, green=0.376587, blue=0.741089)
    kDimGray: wpilib._wpilib.Color # value = Color(red=0.411743, green=0.411743, blue=0.411743)
    kDodgerBlue: wpilib._wpilib.Color # value = Color(red=0.117554, green=0.564819, blue=1.000000)
    kFirebrick: wpilib._wpilib.Color # value = Color(red=0.698120, green=0.133423, blue=0.133423)
    kFirstBlue: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.400024, blue=0.702026)
    kFirstRed: wpilib._wpilib.Color # value = Color(red=0.929321, green=0.109741, blue=0.141235)
    kFloralWhite: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.980347, blue=0.941284)
    kForestGreen: wpilib._wpilib.Color # value = Color(red=0.133423, green=0.545044, blue=0.133423)
    kFuchsia: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.000122, blue=1.000000)
    kGainsboro: wpilib._wpilib.Color # value = Color(red=0.862671, green=0.862671, blue=0.862671)
    kGhostWhite: wpilib._wpilib.Color # value = Color(red=0.972534, green=0.972534, blue=1.000000)
    kGold: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.843140, blue=0.000122)
    kGoldenrod: wpilib._wpilib.Color # value = Color(red=0.854858, green=0.647095, blue=0.125610)
    kGray: wpilib._wpilib.Color # value = Color(red=0.502075, green=0.502075, blue=0.502075)
    kGreen: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.502075, blue=0.000122)
    kGreenYellow: wpilib._wpilib.Color # value = Color(red=0.678345, green=1.000000, blue=0.184204)
    kHoneydew: wpilib._wpilib.Color # value = Color(red=0.941284, green=1.000000, blue=0.941284)
    kHotPink: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.411743, blue=0.705933)
    kIndianRed: wpilib._wpilib.Color # value = Color(red=0.803833, green=0.360718, blue=0.360718)
    kIndigo: wpilib._wpilib.Color # value = Color(red=0.294067, green=0.000122, blue=0.509888)
    kIvory: wpilib._wpilib.Color # value = Color(red=1.000000, green=1.000000, blue=0.941284)
    kKhaki: wpilib._wpilib.Color # value = Color(red=0.941284, green=0.901978, blue=0.548950)
    kLavender: wpilib._wpilib.Color # value = Color(red=0.901978, green=0.901978, blue=0.980347)
    kLavenderBlush: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.941284, blue=0.960815)
    kLawnGreen: wpilib._wpilib.Color # value = Color(red=0.486206, green=0.988159, blue=0.000122)
    kLemonChiffon: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.980347, blue=0.803833)
    kLightBlue: wpilib._wpilib.Color # value = Color(red=0.678345, green=0.847046, blue=0.901978)
    kLightCoral: wpilib._wpilib.Color # value = Color(red=0.941284, green=0.502075, blue=0.502075)
    kLightCyan: wpilib._wpilib.Color # value = Color(red=0.878540, green=1.000000, blue=1.000000)
    kLightGoldenrodYellow: wpilib._wpilib.Color # value = Color(red=0.980347, green=0.980347, blue=0.823608)
    kLightGray: wpilib._wpilib.Color # value = Color(red=0.827515, green=0.827515, blue=0.827515)
    kLightGreen: wpilib._wpilib.Color # value = Color(red=0.564819, green=0.933228, blue=0.564819)
    kLightPink: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.713745, blue=0.756958)
    kLightSalmon: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.627563, blue=0.478394)
    kLightSeaGreen: wpilib._wpilib.Color # value = Color(red=0.125610, green=0.698120, blue=0.666626)
    kLightSkyBlue: wpilib._wpilib.Color # value = Color(red=0.529419, green=0.807739, blue=0.980347)
    kLightSlateGray: wpilib._wpilib.Color # value = Color(red=0.466675, green=0.533325, blue=0.599976)
    kLightSteelBlue: wpilib._wpilib.Color # value = Color(red=0.690308, green=0.768677, blue=0.870483)
    kLightYellow: wpilib._wpilib.Color # value = Color(red=1.000000, green=1.000000, blue=0.878540)
    kLime: wpilib._wpilib.Color # value = Color(red=0.000122, green=1.000000, blue=0.000122)
    kLimeGreen: wpilib._wpilib.Color # value = Color(red=0.196167, green=0.803833, blue=0.196167)
    kLinen: wpilib._wpilib.Color # value = Color(red=0.980347, green=0.941284, blue=0.901978)
    kMagenta: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.000122, blue=1.000000)
    kMaroon: wpilib._wpilib.Color # value = Color(red=0.502075, green=0.000122, blue=0.000122)
    kMediumAquamarine: wpilib._wpilib.Color # value = Color(red=0.400024, green=0.803833, blue=0.666626)
    kMediumBlue: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.000122, blue=0.803833)
    kMediumOrchid: wpilib._wpilib.Color # value = Color(red=0.729370, green=0.333374, blue=0.827515)
    kMediumPurple: wpilib._wpilib.Color # value = Color(red=0.576538, green=0.439331, blue=0.858765)
    kMediumSeaGreen: wpilib._wpilib.Color # value = Color(red=0.235229, green=0.702026, blue=0.443237)
    kMediumSlateBlue: wpilib._wpilib.Color # value = Color(red=0.482300, green=0.407837, blue=0.933228)
    kMediumSpringGreen: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.980347, blue=0.603882)
    kMediumTurquoise: wpilib._wpilib.Color # value = Color(red=0.282349, green=0.819702, blue=0.799927)
    kMediumVioletRed: wpilib._wpilib.Color # value = Color(red=0.780396, green=0.082397, blue=0.521606)
    kMidnightBlue: wpilib._wpilib.Color # value = Color(red=0.098022, green=0.098022, blue=0.439331)
    kMintcream: wpilib._wpilib.Color # value = Color(red=0.960815, green=1.000000, blue=0.980347)
    kMistyRose: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.894165, blue=0.882446)
    kMoccasin: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.894165, blue=0.709839)
    kNavajoWhite: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.870483, blue=0.678345)
    kNavy: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.000122, blue=0.502075)
    kOldLace: wpilib._wpilib.Color # value = Color(red=0.992065, green=0.960815, blue=0.901978)
    kOlive: wpilib._wpilib.Color # value = Color(red=0.502075, green=0.502075, blue=0.000122)
    kOliveDrab: wpilib._wpilib.Color # value = Color(red=0.419556, green=0.556763, blue=0.137329)
    kOrange: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.647095, blue=0.000122)
    kOrangeRed: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.270630, blue=0.000122)
    kOrchid: wpilib._wpilib.Color # value = Color(red=0.854858, green=0.439331, blue=0.839233)
    kPaleGoldenrod: wpilib._wpilib.Color # value = Color(red=0.933228, green=0.909790, blue=0.666626)
    kPaleGreen: wpilib._wpilib.Color # value = Color(red=0.596069, green=0.984253, blue=0.596069)
    kPaleTurquoise: wpilib._wpilib.Color # value = Color(red=0.686157, green=0.933228, blue=0.933228)
    kPaleVioletRed: wpilib._wpilib.Color # value = Color(red=0.858765, green=0.439331, blue=0.576538)
    kPapayaWhip: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.937134, blue=0.835327)
    kPeachPuff: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.854858, blue=0.725464)
    kPeru: wpilib._wpilib.Color # value = Color(red=0.803833, green=0.521606, blue=0.246948)
    kPink: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.753052, blue=0.796021)
    kPlum: wpilib._wpilib.Color # value = Color(red=0.866577, green=0.627563, blue=0.866577)
    kPowderBlue: wpilib._wpilib.Color # value = Color(red=0.690308, green=0.878540, blue=0.901978)
    kPurple: wpilib._wpilib.Color # value = Color(red=0.502075, green=0.000122, blue=0.502075)
    kRed: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.000122, blue=0.000122)
    kRosyBrown: wpilib._wpilib.Color # value = Color(red=0.737183, green=0.560669, blue=0.560669)
    kRoyalBlue: wpilib._wpilib.Color # value = Color(red=0.255005, green=0.411743, blue=0.882446)
    kSaddleBrown: wpilib._wpilib.Color # value = Color(red=0.545044, green=0.270630, blue=0.074585)
    kSalmon: wpilib._wpilib.Color # value = Color(red=0.980347, green=0.502075, blue=0.447144)
    kSandyBrown: wpilib._wpilib.Color # value = Color(red=0.956909, green=0.643188, blue=0.376587)
    kSeaGreen: wpilib._wpilib.Color # value = Color(red=0.180298, green=0.545044, blue=0.341187)
    kSeashell: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.960815, blue=0.933228)
    kSienna: wpilib._wpilib.Color # value = Color(red=0.627563, green=0.321655, blue=0.176392)
    kSilver: wpilib._wpilib.Color # value = Color(red=0.753052, green=0.753052, blue=0.753052)
    kSkyBlue: wpilib._wpilib.Color # value = Color(red=0.529419, green=0.807739, blue=0.921509)
    kSlateBlue: wpilib._wpilib.Color # value = Color(red=0.415649, green=0.352905, blue=0.803833)
    kSlateGray: wpilib._wpilib.Color # value = Color(red=0.439331, green=0.502075, blue=0.564819)
    kSnow: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.980347, blue=0.980347)
    kSpringGreen: wpilib._wpilib.Color # value = Color(red=0.000122, green=1.000000, blue=0.497925)
    kSteelBlue: wpilib._wpilib.Color # value = Color(red=0.274536, green=0.509888, blue=0.705933)
    kTan: wpilib._wpilib.Color # value = Color(red=0.823608, green=0.705933, blue=0.548950)
    kTeal: wpilib._wpilib.Color # value = Color(red=0.000122, green=0.502075, blue=0.502075)
    kThistle: wpilib._wpilib.Color # value = Color(red=0.847046, green=0.748901, blue=0.847046)
    kTomato: wpilib._wpilib.Color # value = Color(red=1.000000, green=0.388306, blue=0.278442)
    kTurquoise: wpilib._wpilib.Color # value = Color(red=0.251099, green=0.878540, blue=0.815796)
    kViolet: wpilib._wpilib.Color # value = Color(red=0.933228, green=0.509888, blue=0.933228)
    kWheat: wpilib._wpilib.Color # value = Color(red=0.960815, green=0.870483, blue=0.702026)
    kWhite: wpilib._wpilib.Color # value = Color(red=1.000000, green=1.000000, blue=1.000000)
    kWhiteSmoke: wpilib._wpilib.Color # value = Color(red=0.960815, green=0.960815, blue=0.960815)
    kYellow: wpilib._wpilib.Color # value = Color(red=1.000000, green=1.000000, blue=0.000122)
    kYellowGreen: wpilib._wpilib.Color # value = Color(red=0.603882, green=0.803833, blue=0.196167)
    pass
class Color8Bit():
    """
    Represents colors that can be used with Addressable LEDs.
    """
    def __eq__(self, arg0: Color8Bit) -> bool: ...
    def __hash__(self) -> int: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Constructs a Color8Bit.

        :param red:   Red value (0-255)
        :param green: Green value (0-255)
        :param blue:  Blue value (0-255)

        Constructs a Color8Bit from a Color.

        :param color: The color
        """
    @typing.overload
    def __init__(self, color: Color) -> None: ...
    @typing.overload
    def __init__(self, red: int, green: int, blue: int) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def blue(self) -> int:
        """
        :type: int
        """
    @property
    def green(self) -> int:
        """
        :type: int
        """
    @property
    def red(self) -> int:
        """
        :type: int
        """
    pass
class Compressor(ErrorBase, Sendable):
    """
    Class for operating a compressor connected to a %PCM (Pneumatic Control
    Module).

    The PCM will automatically run in closed loop mode by default whenever a
    Solenoid object is created. For most cases, a Compressor object does not need
    to be instantiated or used in a robot program. This class is only required in
    cases where the robot program needs a more detailed status of the compressor
    or to enable/disable closed loop control.

    Note: you cannot operate the compressor directly from this class as doing so
    would circumvent the safety provided by using the pressure switch and closed
    loop control. You can only turn off closed loop control, thereby stopping
    the compressor from operating.
    """
    def __init__(self, pcmID: int = 0) -> None: 
        """
        Constructor. The default PCM ID is 0.

        :param module: The PCM ID to use (0-62)
        """
    def clearAllPCMStickyFaults(self) -> None: 
        """
        Clear ALL sticky faults inside PCM that Compressor is wired to.

        If a sticky fault is set, then it will be persistently cleared.  Compressor
        drive maybe momentarily disable while flags are being cleared. Care should
        be taken to not call this too frequently, otherwise normal compressor
        functionality may be prevented.

        If no sticky faults are set then this call will have no effect.
        """
    def enabled(self) -> bool: 
        """
        Check if compressor output is active.

        :returns: true if the compressor is on
        """
    def getClosedLoopControl(self) -> bool: 
        """
        Returns true if the compressor will automatically turn on when the
        pressure is low.

        :returns: True if closed loop control of the compressor is enabled. False if
                  disabled.
        """
    def getCompressorCurrent(self) -> float: 
        """
        Query how much current the compressor is drawing.

        :returns: The current through the compressor, in amps
        """
    def getCompressorCurrentTooHighFault(self) -> bool: 
        """
        Query if the compressor output has been disabled due to high current draw.

        :returns: true if PCM is in fault state : Compressor Drive is
                  disabled due to compressor current being too high.
        """
    def getCompressorCurrentTooHighStickyFault(self) -> bool: 
        """
        Query if the compressor output has been disabled due to high current draw
        (sticky).

        A sticky fault will not clear on device reboot, it must be cleared through
        code or the webdash.

        :returns: true if PCM sticky fault is set : Compressor Drive is
                  disabled due to compressor current being too high.
        """
    def getCompressorNotConnectedFault(self) -> bool: 
        """
        Query if the compressor output does not appear to be wired.

        :returns: true if PCM is in fault state : Compressor does not
                  appear to be wired, i.e. compressor is not drawing enough current.
        """
    def getCompressorNotConnectedStickyFault(self) -> bool: 
        """
        Query if the compressor output does not appear to be wired (sticky).

        A sticky fault will not clear on device reboot, it must be cleared through
        code or the webdash.

        :returns: true if PCM sticky fault is set : Compressor does not
                  appear to be wired, i.e. compressor is not drawing enough current.
        """
    def getCompressorShortedFault(self) -> bool: 
        """
        Query if the compressor output has been disabled due to a short circuit.

        :returns: true if PCM is in fault state : Compressor output
                  appears to be shorted.
        """
    def getCompressorShortedStickyFault(self) -> bool: 
        """
        Query if the compressor output has been disabled due to a short circuit
        (sticky).

        A sticky fault will not clear on device reboot, it must be cleared through
        code or the webdash.

        :returns: true if PCM sticky fault is set : Compressor output
                  appears to be shorted.
        """
    def getModule(self) -> int: 
        """
        Gets module number (CAN ID).

        :returns: Module number
        """
    def getPressureSwitchValue(self) -> bool: 
        """
        Check if the pressure switch is triggered.

        :returns: true if pressure is low
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setClosedLoopControl(self, on: bool) -> None: 
        """
        Enables or disables automatically turning the compressor on when the
        pressure is low.

        :param on: Set to true to enable closed loop control of the compressor.
                   False to disable.
        """
    def start(self) -> None: 
        """
        Starts closed-loop control. Note that closed loop control is enabled by
        default.
        """
    def stop(self) -> None: 
        """
        Stops closed-loop control. Note that closed loop control is enabled by
        default.
        """
    pass
class Counter(ErrorBase, wpilib.interfaces._interfaces.CounterBase, Sendable):
    """
    Class for counting the number of ticks on a digital input channel.

    This is a general purpose class for counting repetitive events. It can return
    the number of counts, the period of the most recent cycle, and detect when
    the signal being counted has stopped by supplying a maximum cycle time.

    All counters will immediately start counting - Reset() them if you need them
    to be zeroed before use.
    """
    class Mode():
        """
        Members:

          kTwoPulse

          kSemiperiod

          kPulseLength

          kExternalDirection
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kTwoPulse': <Mode.kTwoPulse: 0>, 'kSemiperiod': <Mode.kSemiperiod: 1>, 'kPulseLength': <Mode.kPulseLength: 2>, 'kExternalDirection': <Mode.kExternalDirection: 3>}
        kExternalDirection: wpilib._wpilib.Counter.Mode # value = <Mode.kExternalDirection: 3>
        kPulseLength: wpilib._wpilib.Counter.Mode # value = <Mode.kPulseLength: 2>
        kSemiperiod: wpilib._wpilib.Counter.Mode # value = <Mode.kSemiperiod: 1>
        kTwoPulse: wpilib._wpilib.Counter.Mode # value = <Mode.kTwoPulse: 0>
        pass
    @typing.overload
    def __init__(self, channel: int) -> None: 
        """
        Create an instance of a counter where no sources are selected.

        They all must be selected by calling functions to specify the upsource and
        the downsource independently.

        This creates a ChipObject counter and initializes status variables
        appropriately.

        The counter will start counting immediately.

        :param mode: The counter mode

        Create an instance of a Counter object.

        Create an up-Counter instance given a channel.

        The counter will start counting immediately.

        :param channel: The DIO channel to use as the up source. 0-9 are on-board,
                        10-25 are on the MXP

        Create an instance of a counter from a Digital Source (such as a Digital
        Input).

        This is used if an existing digital input is to be shared by multiple other
        objects such as encoders or if the Digital Source is not a Digital Input
        channel (such as an Analog Trigger).

        The counter will start counting immediately.

        :param source: A pointer to the existing DigitalSource object. It will be
                       set as the Up Source.

        Create an instance of a Counter object.

        Create an instance of a simple up-Counter given an analog trigger.
        Use the trigger state output from the analog trigger.

        The counter will start counting immediately.

        :param trigger: The reference to the existing AnalogTrigger object.

        Create an instance of a Counter object.

        Creates a full up-down counter given two Digital Sources.

        :param encodingType: The quadrature decoding mode (1x or 2x)
        :param upSource:     The pointer to the DigitalSource to set as the up
                             source
        :param downSource:   The pointer to the DigitalSource to set as the down
                             source
        :param inverted:     True to invert the output (reverse the direction)
        """
    @typing.overload
    def __init__(self, encodingType: wpilib.interfaces._interfaces.CounterBase.EncodingType, upSource: DigitalSource, downSource: DigitalSource, inverted: bool) -> None: ...
    @typing.overload
    def __init__(self, mode: Counter.Mode = Mode.kTwoPulse) -> None: ...
    @typing.overload
    def __init__(self, source: DigitalSource) -> None: ...
    @typing.overload
    def __init__(self, trigger: AnalogTrigger) -> None: ...
    def clearDownSource(self) -> None: 
        """
        Disable the down counting source to the counter.
        """
    def clearUpSource(self) -> None: 
        """
        Disable the up counting source to the counter.
        """
    def get(self) -> int: 
        """
        Read the current counter value.

        Read the value at this instant. It may still be running, so it reflects the
        current value. Next time it is read, it might have a different value.
        """
    def getDirection(self) -> bool: 
        """
        The last direction the counter value changed.

        :returns: The last direction the counter value changed.
        """
    def getFPGAIndex(self) -> int: ...
    def getPeriod(self) -> float: 
        """
        Get the Period of the most recent count.

        Returns the time interval of the most recent count. This can be used for
        velocity calculations to determine shaft speed.

        :returns: The period between the last two pulses in units of seconds.
        """
    def getSamplesToAverage(self) -> int: 
        """
        Get the Samples to Average which specifies the number of samples of the
        timer to average when calculating the period.

        Perform averaging to account for mechanical imperfections or as
        oversampling to increase resolution.

        :returns: The number of samples being averaged (from 1 to 127)
        """
    def getStopped(self) -> bool: 
        """
        Determine if the clock is stopped.

        Determine if the clocked input is stopped based on the MaxPeriod value set
        using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the
        device (and counter) are assumed to be stopped and it returns true.

        :returns: Returns true if the most recent counter period exceeds the
                  MaxPeriod value set by SetMaxPeriod.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def reset(self) -> None: 
        """
        Reset the Counter to zero.

        Set the counter value to zero. This doesn't effect the running state of the
        counter, just sets the current value to zero.
        """
    @typing.overload
    def setDownSource(self, analogTrigger: AnalogTrigger, triggerType: AnalogTriggerType) -> None: 
        """
        Set the down counting source to be a digital input channel.

        :param channel: The DIO channel to use as the up source. 0-9 are on-board,
                        10-25 are on the MXP

        Set the down counting source to be an analog trigger.

        :param analogTrigger: The analog trigger object that is used for the Down
                              Source
        :param triggerType:   The analog trigger output that will trigger the
                              counter.
        """
    @typing.overload
    def setDownSource(self, channel: int) -> None: ...
    @typing.overload
    def setDownSource(self, source: DigitalSource) -> None: ...
    def setDownSourceEdge(self, risingEdge: bool, fallingEdge: bool) -> None: 
        """
        Set the edge sensitivity on a down counting source.

        Set the down source to either detect rising edges or falling edges.

        :param risingEdge:  True to trigger on rising edges
        :param fallingEdge: True to trigger on falling edges
        """
    def setExternalDirectionMode(self) -> None: 
        """
        Set external direction mode on this counter.

        Counts are sourced on the Up counter input.
        The Down counter input represents the direction to count.
        """
    def setMaxPeriod(self, maxPeriod: float) -> None: 
        """
        Set the maximum period where the device is still considered "moving".

        Sets the maximum period where the device is considered moving. This value
        is used to determine the "stopped" state of the counter using the
        GetStopped method.

        :param maxPeriod: The maximum period where the counted device is considered
                          moving in seconds.
        """
    def setPulseLengthMode(self, threshold: float) -> None: 
        """
        Configure the counter to count in up or down based on the length of the
        input pulse.

        This mode is most useful for direction sensitive gear tooth sensors.

        :param threshold: The pulse length beyond which the counter counts the
                          opposite direction. Units are seconds.
        """
    def setReverseDirection(self, reverseDirection: bool) -> None: 
        """
        Set the Counter to return reversed sensing on the direction.

        This allows counters to change the direction they are counting in the case
        of 1X and 2X quadrature encoding only. Any other counter mode isn't
        supported.

        :param reverseDirection: true if the value counted should be negated.
        """
    def setSamplesToAverage(self, samplesToAverage: int) -> None: 
        """
        Set the Samples to Average which specifies the number of samples of the
        timer to average when calculating the period. Perform averaging to account
        for mechanical imperfections or as oversampling to increase resolution.

        :param samplesToAverage: The number of samples to average from 1 to 127.
        """
    def setSemiPeriodMode(self, highSemiPeriod: bool) -> None: 
        """
        Set Semi-period mode on this counter.

        Counts up on both rising and falling edges.
        """
    def setUpDownCounterMode(self) -> None: 
        """
        Set standard up / down counting mode on this counter.

        Up and down counts are sourced independently from two inputs.
        """
    @typing.overload
    def setUpSource(self, analogTrigger: AnalogTrigger, triggerType: AnalogTriggerType) -> None: 
        """
        Set the upsource for the counter as a digital input channel.

        :param channel: The DIO channel to use as the up source. 0-9 are on-board,
                        10-25 are on the MXP

        Set the up counting source to be an analog trigger.

        :param analogTrigger: The analog trigger object that is used for the Up
                              Source
        :param triggerType:   The analog trigger output that will trigger the
                              counter.

        Set the source object that causes the counter to count up.

        Set the up counting DigitalSource.

        :param source: Pointer to the DigitalSource object to set as the up source
        """
    @typing.overload
    def setUpSource(self, channel: int) -> None: ...
    @typing.overload
    def setUpSource(self, source: DigitalSource) -> None: ...
    def setUpSourceEdge(self, risingEdge: bool, fallingEdge: bool) -> None: 
        """
        Set the edge sensitivity on an up counting source.

        Set the up source to either detect rising edges or falling edges or both.

        :param risingEdge:  True to trigger on rising edges
        :param fallingEdge: True to trigger on falling edges
        """
    def setUpdateWhenEmpty(self, enabled: bool) -> None: 
        """
        Select whether you want to continue updating the event timer output when
        there are no samples captured.

        The output of the event timer has a buffer of periods that are averaged and
        posted to a register on the FPGA.  When the timer detects that the event
        source has stopped (based on the MaxPeriod) the buffer of samples to be
        averaged is emptied.  If you enable the update when empty, you will be
        notified of the stopped source and the event time will report 0 samples.
        If you disable update when empty, the most recent average will remain on
        the output until a new sample is acquired.  You will never see 0 samples
        output (except when there have been no events since an FPGA reset) and you
        will likely not see the stopped bit become true (since it is updated at the
        end of an average and there are no samples to average).

        :param enabled: True to enable update when empty
        """
    @property
    def _m_downSource(self) -> DigitalSource:
        """
        :type: DigitalSource
        """
    @property
    def _m_upSource(self) -> DigitalSource:
        """
        :type: DigitalSource
        """
    pass
class MotorSafety(ErrorBase):
    """
    This base class runs a watchdog timer and calls the subclass's StopMotor()
    function if the timeout expires.

    The subclass should call Feed() whenever the motor value is updated.
    """
    def __init__(self) -> None: ...
    def check(self) -> None: 
        """
        Check if this motor has exceeded its timeout.

        This method is called periodically to determine if this motor has exceeded
        its timeout value. If it has, the stop method is called, and the motor is
        shut down until its value is updated again.
        """
    @staticmethod
    def checkMotors() -> None: 
        """
        Check the motors to see if any have timed out.

        This static method is called periodically to poll all the motors and stop
        any that have timed out.
        """
    def feed(self) -> None: 
        """
        Feed the motor safety object.

        Resets the timer on this object that is used to do the timeouts.
        """
    def getDescription(self) -> str: ...
    def getExpiration(self) -> float: 
        """
        Retrieve the timeout value for the corresponding motor safety object.

        :returns: the timeout value in seconds.
        """
    def isAlive(self) -> bool: 
        """
        Determine if the motor is still operating or has timed out.

        :returns: true if the motor is still operating normally and hasn't timed out.
        """
    def isSafetyEnabled(self) -> bool: 
        """
        Return the state of the motor safety enabled flag.

        Return if the motor safety is currently enabled for this device.

        :returns: True if motor safety is enforced for this device.
        """
    def setExpiration(self, expirationTime: float) -> None: 
        """
        Set the expiration time for the corresponding motor safety object.

        :param expirationTime: The timeout value in seconds.
        """
    def setSafetyEnabled(self, enabled: bool) -> None: 
        """
        Enable/disable motor safety for this device.

        Turn on and off the motor safety option for this PWM object.

        :param enabled: True if motor safety is enforced for this object.
        """
    def stopMotor(self) -> None: ...
    pass
class DigitalGlitchFilter(ErrorBase, Sendable):
    """
    Class to enable glitch filtering on a set of digital inputs.

    This class will manage adding and removing digital inputs from a FPGA glitch
    filter. The filter lets the user configure the time that an input must remain
    high or low before it is classified as high or low.
    """
    def __init__(self) -> None: ...
    @typing.overload
    def add(self, input: Counter) -> None: 
        """
        Assigns the DigitalSource to this glitch filter.

        :param input: The DigitalSource to add.

        Assigns the Encoder to this glitch filter.

        :param input: The Encoder to add.

        Assigns the Counter to this glitch filter.

        :param input: The Counter to add.
        """
    @typing.overload
    def add(self, input: DigitalSource) -> None: ...
    @typing.overload
    def add(self, input: Encoder) -> None: ...
    def getPeriodCycles(self) -> int: 
        """
        Gets the number of cycles that the input must not change state for.

        :returns: The number of cycles.
        """
    def getPeriodNanoSeconds(self) -> int: 
        """
        Gets the number of nanoseconds that the input must not change state for.

        :returns: The number of nanoseconds.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    @typing.overload
    def remove(self, input: Counter) -> None: 
        """
        Removes a digital input from this filter.

        Removes the DigitalSource from this glitch filter and re-assigns it to
        the default filter.

        :param input: The DigitalSource to remove.

        Removes an encoder from this filter.

        Removes the Encoder from this glitch filter and re-assigns it to
        the default filter.

        :param input: The Encoder to remove.

        Removes a counter from this filter.

        Removes the Counter from this glitch filter and re-assigns it to
        the default filter.

        :param input: The Counter to remove.
        """
    @typing.overload
    def remove(self, input: DigitalSource) -> None: ...
    @typing.overload
    def remove(self, input: Encoder) -> None: ...
    def setPeriodCycles(self, fpgaCycles: int) -> None: 
        """
        Sets the number of cycles that the input must not change state for.

        :param fpgaCycles: The number of FPGA cycles.
        """
    def setPeriodNanoSeconds(self, nanoseconds: int) -> None: 
        """
        Sets the number of nanoseconds that the input must not change state for.

        :param nanoseconds: The number of nanoseconds.
        """
    pass
class DigitalSource(InterruptableSensorBase, ErrorBase):
    """
    DigitalSource Interface.

    The DigitalSource represents all the possible inputs for a counter or a
    quadrature encoder. The source may be either a digital input or an analog
    input. If the caller just provides a channel, then a digital input will be
    constructed and freed when finished for the source. The source can either be
    a digital input or analog trigger but not both.
    """
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def getAnalogTriggerTypeForRouting(self) -> AnalogTriggerType: ...
    def getChannel(self) -> int: ...
    def getPortHandleForRouting(self) -> int: ...
    def isAnalogTrigger(self) -> bool: ...
    pass
class DigitalOutput(DigitalSource, InterruptableSensorBase, ErrorBase, Sendable):
    """
    Class to write to digital outputs.

    Write values to the digital output channels. Other devices implemented
    elsewhere will allocate channels automatically so for those devices it
    shouldn't be done here.
    """
    def __init__(self, channel: int) -> None: 
        """
        Create an instance of a digital output.

        Create a digital output given a channel.

        :param channel: The digital channel 0-9 are on-board, 10-25 are on the MXP
                        port
        """
    def disablePWM(self) -> None: 
        """
        Change this line from a PWM output back to a static Digital Output line.

        Free up one of the 6 DO PWM generator resources that were in use.
        """
    def enablePWM(self, initialDutyCycle: float) -> None: 
        """
        Enable a PWM Output on this line.

        Allocate one of the 6 DO PWM generator resources from this module.

        Supply the initial duty-cycle to output so as to avoid a glitch when first
        starting.

        The resolution of the duty cycle is 8-bit for low frequencies (1kHz or
        less) but is reduced the higher the frequency of the PWM signal is.

        :param initialDutyCycle: The duty-cycle to start generating. [0..1]
        """
    def get(self) -> bool: 
        """
        Gets the value being output from the Digital Output.

        :returns: the state of the digital output.
        """
    def getAnalogTriggerTypeForRouting(self) -> AnalogTriggerType: 
        """
        :returns: The type of analog trigger output to be used. 0 for Digitals
        """
    def getChannel(self) -> int: 
        """
        :returns: The GPIO channel number that this object represents.
        """
    def getPortHandleForRouting(self) -> int: 
        """
        :returns: The HAL Handle to the specified source.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isAnalogTrigger(self) -> bool: 
        """
        Is source an AnalogTrigger
        """
    def isPulsing(self) -> bool: 
        """
        Determine if the pulse is still going.

        Determine if a previously started pulse is still going.
        """
    def pulse(self, length: float) -> None: 
        """
        Output a single pulse on the digital output line.

        Send a single pulse on the digital output line where the pulse duration is
        specified in seconds. Maximum pulse length is 0.0016 seconds.

        :param length: The pulse length in seconds
        """
    def set(self, value: bool) -> None: 
        """
        Set the value of a digital output.

        Set the value of a digital output to either one (true) or zero (false).

        :param value: 1 (true) for high, 0 (false) for disabled
        """
    def setPWMRate(self, rate: float) -> None: 
        """
        Change the PWM frequency of the PWM output on a Digital Output line.

        The valid range is from 0.6 Hz to 19 kHz.  The frequency resolution is
        logarithmic.

        There is only one PWM frequency for all digital channels.

        :param rate: The frequency to output all digital output PWM signals.
        """
    def setSimDevice(self, device: int) -> None: 
        """
        Indicates this output is used by a simulated device.

        :param device: simulated device handle
        """
    def updateDutyCycle(self, dutyCycle: float) -> None: 
        """
        Change the duty-cycle that is being generated on the line.

        The resolution of the duty cycle is 8-bit for low frequencies (1kHz or
        less) but is reduced the higher the frequency of the PWM signal is.

        :param dutyCycle: The duty-cycle to change to. [0..1]
        """
    pass
class AnalogTriggerOutput(DigitalSource, InterruptableSensorBase, ErrorBase, Sendable):
    """
    Class to represent a specific output from an analog trigger.

    This class is used to get the current output value and also as a
    DigitalSource to provide routing of an output to digital subsystems on the
    FPGA such as Counter, Encoder, and Interrupt.

    The TriggerState output indicates the primary output value of the trigger.
    If the analog signal is less than the lower limit, the output is false. If
    the analog value is greater than the upper limit, then the output is true.
    If the analog value is in between, then the trigger output state maintains
    its most recent value.

    The InWindow output indicates whether or not the analog signal is inside the
    range defined by the limits.

    The RisingPulse and FallingPulse outputs detect an instantaneous transition
    from above the upper limit to below the lower limit, and vise versa. These
    pulses represent a rollover condition of a sensor and can be routed to an up
    / down counter or to interrupts. Because the outputs generate a pulse, they
    cannot be read directly. To help ensure that a rollover condition is not
    missed, there is an average rejection filter available that operates on the
    upper 8 bits of a 12 bit number and selects the nearest outlyer of 3 samples.
    This will reject a sample that is (due to averaging or sampling) errantly
    between the two limits. This filter will fail if more than one sample in a
    row is errantly in between the two limits. You may see this problem if
    attempting to use this feature with a mechanical rollover sensor, such as a
    360 degree no-stop potentiometer without signal conditioning, because the
    rollover transition is not sharp / clean enough. Using the averaging engine
    may help with this, but rotational speeds of the sensor will then be limited.
    """
    def __init__(self, trigger: AnalogTrigger, outputType: AnalogTriggerType) -> None: 
        """
        Create an object that represents one of the four outputs from an analog
        trigger.

        Because this class derives from DigitalSource, it can be passed into
        routing functions for Counter, Encoder, etc.

        :param trigger:    A pointer to the trigger for which this is an output.
        :param outputType: An enum that specifies the output on the trigger to
                           represent.
        """
    def get(self) -> bool: 
        """
        Get the state of the analog trigger output.

        :returns: The state of the analog trigger output.
        """
    def getAnalogTriggerTypeForRouting(self) -> AnalogTriggerType: 
        """
        :returns: The type of analog trigger output to be used.
        """
    def getChannel(self) -> int: 
        """
        :returns: The channel of the source.
        """
    def getPortHandleForRouting(self) -> int: 
        """
        :returns: The HAL Handle to the specified source.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isAnalogTrigger(self) -> bool: 
        """
        Is source an AnalogTrigger
        """
    pass
class SolenoidBase(ErrorBase):
    """
    SolenoidBase class is the common base class for the Solenoid and
    DoubleSolenoid classes.
    """
    def __init__(self, pcmID: int) -> None: 
        """
        Constructor.

        :param moduleNumber: The CAN PCM ID.
        """
    def clearAllPCMStickyFaults(self) -> None: 
        """
        Clear ALL sticky faults inside PCM that Compressor is wired to.

        If a sticky fault is set, then it will be persistently cleared.  Compressor
        drive maybe momentarily disable while flags are being cleared. Care should
        be taken to not call this too frequently, otherwise normal compressor
        functionality may be prevented.

        If no sticky faults are set then this call will have no effect.
        """
    @staticmethod
    def clearAllPCMStickyFaultsByModule(module: int) -> None: 
        """
        Clear ALL sticky faults inside PCM that Compressor is wired to.

        If a sticky fault is set, then it will be persistently cleared.  Compressor
        drive maybe momentarily disable while flags are being cleared. Care should
        be taken to not call this too frequently, otherwise normal compressor
        functionality may be prevented.

        If no sticky faults are set then this call will have no effect.

        :param module: the module to read from
        """
    def getAll(self) -> int: 
        """
        Read all 8 solenoids as a single byte

        :returns: The current value of all 8 solenoids on the module.
        """
    @staticmethod
    def getAllByModule(module: int) -> int: 
        """
        Read all 8 solenoids as a single byte

        :param module: the module to read from

        :returns: The current value of all 8 solenoids on the module.
        """
    def getModuleNumber(self) -> int: 
        """
        Get the CAN ID of the module this solenoid is connected to.

        :returns: the module number.
        """
    def getPCMSolenoidBlackList(self) -> int: 
        """
        Reads complete solenoid blacklist for all 8 solenoids as a single byte.

        If a solenoid is shorted, it is added to the blacklist and
        disabled until power cycle, or until faults are cleared.
        @see ClearAllPCMStickyFaults()

        :returns: The solenoid blacklist of all 8 solenoids on the module.
        """
    @staticmethod
    def getPCMSolenoidBlackListByModule(module: int) -> int: 
        """
        Reads complete solenoid blacklist for all 8 solenoids as a single byte.

        If a solenoid is shorted, it is added to the blacklist and
        disabled until power cycle, or until faults are cleared.
        @see ClearAllPCMStickyFaults()

        :param module: the module to read from

        :returns: The solenoid blacklist of all 8 solenoids on the module.
        """
    def getPCMSolenoidVoltageFault(self) -> bool: 
        """
        :returns: true if PCM is in fault state : The common highside solenoid
                  voltage rail is too low, most likely a solenoid channel is shorted.
        """
    @staticmethod
    def getPCMSolenoidVoltageFaultByModule(module: int) -> bool: 
        """
        :param module: the module to read from

        :returns: true if PCM is in fault state : The common highside solenoid
                  voltage rail is too low, most likely a solenoid channel is shorted.
        """
    def getPCMSolenoidVoltageStickyFault(self) -> bool: 
        """
        :returns: true if PCM sticky fault is set : The common highside solenoid
                  voltage rail is too low, most likely a solenoid channel is shorted.
        """
    @staticmethod
    def getPCMSolenoidVoltageStickyFaultByModule(module: int) -> bool: 
        """
        :param module: the module to read from

        :returns: true if PCM sticky fault is set : The common highside solenoid
                  voltage rail is too low, most likely a solenoid channel is shorted.
        """
    @property
    def _m_moduleNumber(self) -> int:
        """
        :type: int
        """
    @_m_moduleNumber.setter
    def _m_moduleNumber(self, arg0: int) -> None:
        pass
    _m_maxModules = 63
    _m_maxPorts = 8
    pass
class DriverStation(ErrorBase):
    """
    Provide access to the network communication data to / from the Driver
    Station.
    """
    class Alliance():
        """
        Members:

          kRed

          kBlue

          kInvalid
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kRed': <Alliance.kRed: 0>, 'kBlue': <Alliance.kBlue: 1>, 'kInvalid': <Alliance.kInvalid: 2>}
        kBlue: wpilib._wpilib.DriverStation.Alliance # value = <Alliance.kBlue: 1>
        kInvalid: wpilib._wpilib.DriverStation.Alliance # value = <Alliance.kInvalid: 2>
        kRed: wpilib._wpilib.DriverStation.Alliance # value = <Alliance.kRed: 0>
        pass
    class MatchType():
        """
        Members:

          kNone

          kPractice

          kQualification

          kElimination
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kNone': <MatchType.kNone: 0>, 'kPractice': <MatchType.kPractice: 1>, 'kQualification': <MatchType.kQualification: 2>, 'kElimination': <MatchType.kElimination: 3>}
        kElimination: wpilib._wpilib.DriverStation.MatchType # value = <MatchType.kElimination: 3>
        kNone: wpilib._wpilib.DriverStation.MatchType # value = <MatchType.kNone: 0>
        kPractice: wpilib._wpilib.DriverStation.MatchType # value = <MatchType.kPractice: 1>
        kQualification: wpilib._wpilib.DriverStation.MatchType # value = <MatchType.kQualification: 2>
        pass
    def _getData(self) -> None: 
        """
        Copy data from the DS task for the user.

        If no new data exists, it will just be returned, otherwise
        the data will be copied from the DS polling loop.
        """
    def getAlliance(self) -> DriverStation.Alliance: 
        """
        Return the alliance that the driver station says it is on.

        This could return kRed or kBlue.

        :returns: The Alliance enum (kRed, kBlue or kInvalid)
        """
    def getBatteryVoltage(self) -> float: 
        """
        Read the battery voltage.

        :returns: The battery voltage in Volts.
        """
    def getControlState(self) -> typing.Tuple[bool, bool, bool]: 
        """
        More efficient way to determine what state the robot is in.

        :returns: booleans representing enabled, isautonomous, istest

        .. versionadded:: 2019.2.1

        .. note:: This function only exists in RobotPy
        """
    def getEventName(self) -> str: 
        """
        Returns the name of the competition event provided by the FMS.

        :returns: A string containing the event name
        """
    def getGameSpecificMessage(self) -> str: 
        """
        Returns the game specific message provided by the FMS.

        :returns: A string containing the game specific message.
        """
    @staticmethod
    def getInstance() -> DriverStation: 
        """
        Return a reference to the singleton DriverStation.

        :returns: Reference to the DS instance
        """
    def getJoystickAxisType(self, stick: int, axis: int) -> int: 
        """
        Returns the types of Axes on a given joystick port.

        :param stick: The joystick port number and the target axis

        :returns: What type of axis the axis is reporting to be
        """
    def getJoystickIsXbox(self, stick: int) -> bool: 
        """
        Returns a boolean indicating if the controller is an xbox controller.

        :param stick: The joystick port number

        :returns: A boolean that is true if the controller is an xbox controller.
        """
    def getJoystickName(self, stick: int) -> str: 
        """
        Returns the name of the joystick at the given port.

        :param stick: The joystick port number

        :returns: The name of the joystick at the given port
        """
    def getJoystickType(self, stick: int) -> int: 
        """
        Returns the type of joystick at a given port.

        :param stick: The joystick port number

        :returns: The HID type of joystick at the given port
        """
    def getLocation(self) -> int: 
        """
        Return the driver station location on the field.

        This could return 1, 2, or 3.

        :returns: The location of the driver station (1-3, 0 for invalid)
        """
    def getMatchNumber(self) -> int: 
        """
        Returns the match number provided by the FMS.

        :returns: The number of the match
        """
    def getMatchTime(self) -> float: 
        """
        Return the approximate match time.

        The FMS does not send an official match time to the robots, but does send
        an approximate match time. The value will count down the time remaining in
        the current period (auto or teleop).

        Warning: This is not an official time (so it cannot be used to dispute ref
        calls or guarantee that a function will trigger before the match ends).

        The Practice Match function of the DS approximates the behavior seen on
        the field.

        :returns: Time remaining in current match period (auto or teleop)
        """
    def getMatchType(self) -> DriverStation.MatchType: 
        """
        Returns the type of match being played provided by the FMS.

        :returns: The match type enum (kNone, kPractice, kQualification,
                  kElimination)
        """
    def getReplayNumber(self) -> int: 
        """
        Returns the number of times the current match has been replayed from the
        FMS.

        :returns: The number of replays
        """
    def getStickAxis(self, stick: int, axis: int) -> float: 
        """
        Get the value of the axis on a joystick.

        This depends on the mapping of the joystick connected to the specified
        port.

        :param stick: The joystick to read.
        :param axis:  The analog axis value to read from the joystick.

        :returns: The value of the axis on the joystick.
        """
    def getStickAxisCount(self, stick: int) -> int: 
        """
        Returns the number of axes on a given joystick port.

        :param stick: The joystick port number

        :returns: The number of axes on the indicated joystick
        """
    def getStickButton(self, stick: int, button: int) -> bool: 
        """
        The state of one joystick button. Button indexes begin at 1.

        :param stick:  The joystick to read.
        :param button: The button index, beginning at 1.

        :returns: The state of the joystick button.
        """
    def getStickButtonCount(self, stick: int) -> int: 
        """
        Returns the number of buttons on a given joystick port.

        :param stick: The joystick port number

        :returns: The number of buttons on the indicated joystick
        """
    def getStickButtonPressed(self, stick: int, button: int) -> bool: 
        """
        Whether one joystick button was pressed since the last check. Button
        indexes begin at 1.

        :param stick:  The joystick to read.
        :param button: The button index, beginning at 1.

        :returns: Whether the joystick button was pressed since the last check.
        """
    def getStickButtonReleased(self, stick: int, button: int) -> bool: 
        """
        Whether one joystick button was released since the last check. Button
        indexes begin at 1.

        :param stick:  The joystick to read.
        :param button: The button index, beginning at 1.

        :returns: Whether the joystick button was released since the last check.
        """
    def getStickButtons(self, stick: int) -> int: 
        """
        The state of the buttons on the joystick.

        :param stick: The joystick to read.

        :returns: The state of the buttons on the joystick.
        """
    def getStickPOV(self, stick: int, pov: int) -> int: 
        """
        Get the state of a POV on the joystick.

        :returns: the angle of the POV in degrees, or -1 if the POV is not pressed.
        """
    def getStickPOVCount(self, stick: int) -> int: 
        """
        Returns the number of POVs on a given joystick port.

        :param stick: The joystick port number

        :returns: The number of POVs on the indicated joystick
        """
    def inAutonomous(self, entering: bool) -> None: 
        """
        Only to be used to tell the Driver Station what code you claim to be
        executing for diagnostic purposes only.

        :param entering: If true, starting autonomous code; if false, leaving
                         autonomous code.
        """
    def inDisabled(self, entering: bool) -> None: 
        """
        Only to be used to tell the Driver Station what code you claim to be
        executing for diagnostic purposes only.

        :param entering: If true, starting disabled code; if false, leaving disabled
                         code.
        """
    def inOperatorControl(self, entering: bool) -> None: 
        """
        Only to be used to tell the Driver Station what code you claim to be
        executing for diagnostic purposes only.

        :param entering: If true, starting teleop code; if false, leaving teleop
                         code.
        """
    def inTest(self, entering: bool) -> None: 
        """
        Only to be used to tell the Driver Station what code you claim to be
        executing for diagnostic purposes only.

        :param entering: If true, starting test code; if false, leaving test code.
        """
    def isAutonomous(self) -> bool: 
        """
        Check if the DS is commanding autonomous mode.

        :returns: True if the robot is being commanded to be in autonomous mode
        """
    def isAutonomousEnabled(self) -> bool: 
        """
        Check if the DS is commanding autonomous mode and if it has enabled the
        robot.

        :returns: True if the robot is being commanded to be in autonomous mode and
                  enabled.
        """
    def isDSAttached(self) -> bool: 
        """
        Check if the DS is attached.

        :returns: True if the DS is connected to the robot
        """
    def isDisabled(self) -> bool: 
        """
        Check if the robot is disabled.

        :returns: True if the robot is explicitly disabled or the DS is not connected
        """
    def isEStopped(self) -> bool: 
        """
        Check if the robot is e-stopped.

        :returns: True if the robot is e-stopped
        """
    def isEnabled(self) -> bool: 
        """
        Check if the DS has enabled the robot.

        :returns: True if the robot is enabled and the DS is connected
        """
    def isFMSAttached(self) -> bool: 
        """
        Is the driver station attached to a Field Management System?

        :returns: True if the robot is competing on a field being controlled by a
                  Field Management System
        """
    def isJoystickConnected(self, stick: int) -> bool: 
        """
        Returns if a joystick is connected to the Driver Station.

        This makes a best effort guess by looking at the reported number of axis,
        buttons, and POVs attached.

        :param stick: The joystick port number

        :returns: true if a joystick is connected
        """
    def isJoystickConnectionWarningSilenced(self) -> bool: 
        """
        Returns whether joystick connection warnings are silenced. This will
        always return false when connected to the FMS.

        :returns: Whether joystick connection warnings are silenced.
        """
    def isNewControlData(self) -> bool: 
        """
        Has a new control packet from the driver station arrived since the last
        time this function was called?

        Warning: If you call this function from more than one place at the same
        time, you will not get the intended behavior.

        :returns: True if the control data has been updated since the last call.
        """
    def isOperatorControl(self) -> bool: 
        """
        Check if the DS is commanding teleop mode.

        :returns: True if the robot is being commanded to be in teleop mode
        """
    def isOperatorControlEnabled(self) -> bool: 
        """
        Check if the DS is commanding teleop mode and if it has enabled the robot.

        :returns: True if the robot is being commanded to be in teleop mode and
                  enabled.
        """
    def isTest(self) -> bool: 
        """
        Check if the DS is commanding test mode.

        :returns: True if the robot is being commanded to be in test mode
        """
    @staticmethod
    def reportError(error: str, printTrace: bool_) -> object: 
        """
        Report error to Driver Station, and also prints error to `sys.stderr`.
        Optionally appends stack trace to error message.

        :param printTrace: If True, append stack trace to error string

        The error is also printed to the program console.
        """
    @staticmethod
    def reportWarning(error: str, printTrace: bool_) -> object: 
        """
        Report warning to Driver Station, and also prints error to `sys.stderr`.
        Optionally appends stack trace to error message.

        :param printTrace: If True, append stack trace to error string

        The error is also printed to the program console.
        """
    def silenceJoystickConnectionWarning(self, silence: bool) -> None: 
        """
        Allows the user to specify whether they want joystick connection warnings
        to be printed to the console. This setting is ignored when the FMS is
        connected -- warnings will always be on in that scenario.

        :param silence: Whether warning messages should be silenced.
        """
    @typing.overload
    def waitForData(self) -> None: 
        """
        Wait until a new packet comes from the driver station.

        This blocks on a semaphore, so the waiting is efficient.

        This is a good way to delay processing until there is new driver station
        data to act on.

        Checks if new control data has arrived since the last waitForData call
        on the current thread. If new data has not arrived, returns immediately.

        Wait until a new packet comes from the driver station, or wait for a
        timeout.

        Checks if new control data has arrived since the last waitForData call
        on the current thread. If new data has not arrived, returns immediately.

        If the timeout is less then or equal to 0, wait indefinitely.

        Timeout is in milliseconds

        This blocks on a semaphore, so the waiting is efficient.

        This is a good way to delay processing until there is new driver station
        data to act on.

        :param timeout: Timeout time in seconds

        :returns: true if new data, otherwise false
        """
    @typing.overload
    def waitForData(self, timeout: float) -> bool: ...
    def wakeupWaitForData(self) -> None: 
        """
        Forces WaitForData() to return immediately.
        """
    kJoystickPorts = 6
    pass
class DutyCycle(ErrorBase, Sendable):
    """
    Class to read a duty cycle PWM input.

    PWM input signals are specified with a frequency and a ratio of high to
    low in that frequency. There are 8 of these in the roboRIO, and they can be
    attached to any DigitalSource.

    These can be combined as the input of an AnalogTrigger to a Counter in
    order to implement rollover checking.
    """
    def __init__(self, source: DigitalSource) -> None: 
        """
        Constructs a DutyCycle input from a DigitalSource input.

        This class does not own the inputted source.

        :param source: The DigitalSource to use.
        """
    def __repr__(self) -> str: ...
    def _initSendable(self, builder: SendableBuilder) -> None: ...
    def getFPGAIndex(self) -> int: 
        """
        Get the FPGA index for the DutyCycle.

        :returns: the FPGA index
        """
    def getFrequency(self) -> int: 
        """
        Get the frequency of the duty cycle signal.

        :returns: frequency in Hertz
        """
    def getOutput(self) -> float: 
        """
        Get the output ratio of the duty cycle signal.

        0 means always low, 1 means always high.

        :returns: output ratio between 0 and 1
        """
    def getOutputRaw(self) -> int: 
        """
        Get the raw output ratio of the duty cycle signal.

        0 means always low, an output equal to
        GetOutputScaleFactor() means always high.

        :returns: output ratio in raw units
        """
    def getOutputScaleFactor(self) -> int: 
        """
        Get the scale factor of the output.

        An output equal to this value is always high, and then linearly scales
        down to 0. Divide the result of getOutputRaw by this in order to get the
        percentage between 0 and 1.

        :returns: the output scale factor
        """
    def getSourceChannel(self) -> int: 
        """
        Get the channel of the source.

        :returns: the source channel
        """
    pass
class DutyCycleEncoder(ErrorBase, Sendable):
    """
    Class for supporting duty cycle/PWM encoders, such as the US Digital MA3 with
    PWM Output, the CTRE Mag Encoder, the Rev Hex Encoder, and the AM Mag
    Encoder.
    """
    @typing.overload
    def __init__(self, channel: int) -> None: 
        """
        Construct a new DutyCycleEncoder on a specific channel.

        :param channel: the channel to attach to

        Construct a new DutyCycleEncoder attached to an existing DutyCycle object.

        :param dutyCycle: the duty cycle to attach to

        Construct a new DutyCycleEncoder attached to a DigitalSource object.

        :param source: the digital source to attach to
        """
    @typing.overload
    def __init__(self, digitalSource: DigitalSource) -> None: ...
    @typing.overload
    def __init__(self, dutyCycle: DutyCycle) -> None: ...
    def __repr__(self) -> str: ...
    def get(self) -> turns: 
        """
        Get the encoder value since the last reset.

        This is reported in rotations since the last reset.

        :returns: the encoder value in rotations
        """
    def getDistance(self) -> float: 
        """
        Get the distance the sensor has driven since the last reset as scaled by
        the value from SetDistancePerRotation.

        :returns: The distance driven since the last reset
        """
    def getDistancePerRotation(self) -> float: 
        """
        Get the distance per rotation for this encoder.

        :returns: The scale factor that will be used to convert rotation to useful
                  units.
        """
    def getFPGAIndex(self) -> int: 
        """
        Get the FPGA index for the DutyCycleEncoder.

        :returns: the FPGA index
        """
    def getFrequency(self) -> int: 
        """
        Get the frequency in Hz of the duty cycle signal from the encoder.

        :returns: duty cycle frequency in Hz
        """
    def getSourceChannel(self) -> int: 
        """
        Get the channel of the source.

        :returns: the source channel
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isConnected(self) -> bool: 
        """
        Get if the sensor is connected

        This uses the duty cycle frequency to determine if the sensor is connected.
        By default, a value of 100 Hz is used as the threshold, and this value can
        be changed with SetConnectedFrequencyThreshold.

        :returns: true if the sensor is connected
        """
    def reset(self) -> None: 
        """
        Reset the Encoder distance to zero.
        """
    def setConnectedFrequencyThreshold(self, frequency: int) -> None: 
        """
        Change the frequency threshold for detecting connection used by
        IsConnected.

        :param frequency: the minimum frequency in Hz.
        """
    def setDistancePerRotation(self, distancePerRotation: float) -> None: 
        """
        Set the distance per rotation of the encoder. This sets the multiplier used
        to determine the distance driven based on the rotation value from the
        encoder. Set this value based on the how far the mechanism travels in 1
        rotation of the encoder, and factor in gearing reductions following the
        encoder shaft. This distance can be in any units you like, linear or
        angular.

        :param distancePerRotation: the distance per rotation of the encoder
        """
    pass
class Encoder(ErrorBase, wpilib.interfaces._interfaces.CounterBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Class to read quad encoders.

    Quadrature encoders are devices that count shaft rotation and can sense
    direction. The output of the QuadEncoder class is an integer that can count
    either up or down, and can go negative for reverse direction counting. When
    creating QuadEncoders, a direction is supplied that changes the sense of the
    output to make code more readable if the encoder is mounted such that forward
    movement generates negative values. Quadrature encoders have two digital
    outputs, an A Channel and a B Channel that are out of phase with each other
    to allow the FPGA to do direction sensing.

    All encoders will immediately start counting - Reset() them if you need them
    to be zeroed before use.
    """
    class IndexingType():
        """
        Members:

          kResetWhileHigh

          kResetWhileLow

          kResetOnFallingEdge

          kResetOnRisingEdge
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kResetWhileHigh': <IndexingType.kResetWhileHigh: 0>, 'kResetWhileLow': <IndexingType.kResetWhileLow: 1>, 'kResetOnFallingEdge': <IndexingType.kResetOnFallingEdge: 2>, 'kResetOnRisingEdge': <IndexingType.kResetOnRisingEdge: 3>}
        kResetOnFallingEdge: wpilib._wpilib.Encoder.IndexingType # value = <IndexingType.kResetOnFallingEdge: 2>
        kResetOnRisingEdge: wpilib._wpilib.Encoder.IndexingType # value = <IndexingType.kResetOnRisingEdge: 3>
        kResetWhileHigh: wpilib._wpilib.Encoder.IndexingType # value = <IndexingType.kResetWhileHigh: 0>
        kResetWhileLow: wpilib._wpilib.Encoder.IndexingType # value = <IndexingType.kResetWhileLow: 1>
        pass
    @typing.overload
    def __init__(self, aChannel: int, bChannel: int, reverseDirection: bool = False, encodingType: wpilib.interfaces._interfaces.CounterBase.EncodingType = EncodingType.k4X) -> None: 
        """
        Encoder constructor.

        Construct a Encoder given a and b channels.

        The counter will start counting immediately.

        :param aChannel:         The a channel DIO channel. 0-9 are on-board, 10-25
                                 are on the MXP port
        :param bChannel:         The b channel DIO channel. 0-9 are on-board, 10-25
                                 are on the MXP port
        :param reverseDirection: represents the orientation of the encoder and
                                 inverts the output values if necessary so forward
                                 represents positive values.
        :param encodingType:     either k1X, k2X, or k4X to indicate 1X, 2X or 4X
                                 decoding. If 4X is selected, then an encoder FPGA
                                 object is used and the returned counts will be 4x
                                 the encoder spec'd value since all rising and
                                 falling edges are counted. If 1X or 2X are selected
                                 then a counter object will be used and the returned
                                 value will either exactly match the spec'd count or
                                 be double (2x) the spec'd count.
        """
    @typing.overload
    def __init__(self, aSource: DigitalSource, bSource: DigitalSource, reverseDirection: bool = False, encodingType: wpilib.interfaces._interfaces.CounterBase.EncodingType = EncodingType.k4X) -> None: ...
    def get(self) -> int: 
        """
        Gets the current count.

        Returns the current count on the Encoder. This method compensates for the
        decoding type.

        :returns: Current count from the Encoder adjusted for the 1x, 2x, or 4x scale
                  factor.
        """
    def getDirection(self) -> bool: 
        """
        The last direction the encoder value changed.

        :returns: The last direction the encoder value changed.
        """
    def getDistance(self) -> float: 
        """
        Get the distance the robot has driven since the last reset.

        :returns: The distance driven since the last reset as scaled by the value
                  from SetDistancePerPulse().
        """
    def getDistancePerPulse(self) -> float: 
        """
        Get the distance per pulse for this encoder.

        :returns: The scale factor that will be used to convert pulses to useful
                  units.
        """
    def getEncodingScale(self) -> int: 
        """
        The encoding scale factor 1x, 2x, or 4x, per the requested encodingType.

        Used to divide raw edge counts down to spec'd counts.
        """
    def getFPGAIndex(self) -> int: ...
    def getPeriod(self) -> float: 
        """
        Returns the period of the most recent pulse.

        Returns the period of the most recent Encoder pulse in seconds. This method
        compensates for the decoding type.

        Warning: This returns unscaled periods. Use GetRate() for rates that are
        scaled using the value from SetDistancePerPulse().

        :returns: Period in seconds of the most recent pulse.
        """
    def getRate(self) -> float: 
        """
        Get the current rate of the encoder.

        Units are distance per second as scaled by the value from
        SetDistancePerPulse().

        :returns: The current rate of the encoder.
        """
    def getRaw(self) -> int: 
        """
        Gets the raw value from the encoder.

        The raw value is the actual count unscaled by the 1x, 2x, or 4x scale
        factor.

        :returns: Current raw count from the encoder
        """
    def getSamplesToAverage(self) -> int: 
        """
        Get the Samples to Average which specifies the number of samples of the
        timer to average when calculating the period.

        Perform averaging to account for mechanical imperfections or as
        oversampling to increase resolution.

        :returns: The number of samples being averaged (from 1 to 127)
        """
    def getStopped(self) -> bool: 
        """
        Determine if the encoder is stopped.

        Using the MaxPeriod value, a boolean is returned that is true if the
        encoder is considered stopped and false if it is still moving. A stopped
        encoder is one where the most recent pulse width exceeds the MaxPeriod.

        :returns: True if the encoder is considered stopped.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidGet(self) -> float: ...
    def reset(self) -> None: 
        """
        Reset the Encoder distance to zero.

        Resets the current count to zero on the encoder.
        """
    def setDistancePerPulse(self, distancePerPulse: float) -> None: 
        """
        Set the distance per pulse for this encoder.

        This sets the multiplier used to determine the distance driven based on the
        count value from the encoder.

        Do not include the decoding type in this scale.  The library already
        compensates for the decoding type.

        Set this value based on the encoder's rated Pulses per Revolution and
        factor in gearing reductions following the encoder shaft.

        This distance can be in any units you like, linear or angular.

        :param distancePerPulse: The scale factor that will be used to convert
                                 pulses to useful units.
        """
    @typing.overload
    def setIndexSource(self, channel: int, type: Encoder.IndexingType = IndexingType.kResetOnRisingEdge) -> None: 
        """
        Set the index source for the encoder.

        When this source is activated, the encoder count automatically resets.

        :param channel: A DIO channel to set as the encoder index
        :param type:    The state that will cause the encoder to reset

        Set the index source for the encoder.

        When this source is activated, the encoder count automatically resets.

        :param channel: A digital source to set as the encoder index
        :param type:    The state that will cause the encoder to reset
        """
    @typing.overload
    def setIndexSource(self, source: DigitalSource, type: Encoder.IndexingType = IndexingType.kResetOnRisingEdge) -> None: ...
    def setMaxPeriod(self, maxPeriod: float) -> None: ...
    def setMinRate(self, minRate: float) -> None: 
        """
        Set the minimum rate of the device before the hardware reports it stopped.

        :param minRate: The minimum rate.  The units are in distance per second as
                        scaled by the value from SetDistancePerPulse().
        """
    def setReverseDirection(self, reverseDirection: bool) -> None: 
        """
        Set the direction sensing for this encoder.

        This sets the direction sensing on the encoder so that it could count in
        the correct software direction regardless of the mounting.

        :param reverseDirection: true if the encoder direction should be reversed
        """
    def setSamplesToAverage(self, samplesToAverage: int) -> None: 
        """
        Set the Samples to Average which specifies the number of samples of the
        timer to average when calculating the period.

        Perform averaging to account for mechanical imperfections or as
        oversampling to increase resolution.

        :param samplesToAverage: The number of samples to average from 1 to 127.
        """
    def setSimDevice(self, device: int) -> None: 
        """
        Indicates this encoder is used by a simulated device.

        :param device: simulated device handle
        """
    pass
class Error():
    """
    Error object represents a library error.
    """
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, code: int, contextMessage: str, filename: str, function: str, lineNumber: int, originatingObject: ErrorBase) -> None: ...
    def __lt__(self, arg0: Error) -> bool: ...
    def clear(self) -> None: ...
    def getCode(self) -> int: ...
    def getFilename(self) -> str: ...
    def getFunction(self) -> str: ...
    def getLineNumber(self) -> int: ...
    def getMessage(self) -> str: ...
    def getOriginatingObject(self) -> ErrorBase: ...
    def getTimestamp(self) -> float: ...
    def set(self, code: int, contextMessage: str, filename: str, function: str, lineNumber: int, originatingObject: ErrorBase) -> None: ...
    pass
class ADXL345_I2C(ErrorBase, wpilib.interfaces._interfaces.Accelerometer, Sendable):
    """
    ADXL345 Accelerometer on I2C.

    This class allows access to a Analog Devices ADXL345 3-axis accelerometer on
    an I2C bus. This class assumes the default (not alternate) sensor address of
    0x1D (7-bit address).
    """
    class AllAxes():
        def __init__(self) -> None: ...
        @property
        def XAxis(self) -> float:
            """
            :type: float
            """
        @XAxis.setter
        def XAxis(self, arg0: float) -> None:
            pass
        @property
        def YAxis(self) -> float:
            """
            :type: float
            """
        @YAxis.setter
        def YAxis(self, arg0: float) -> None:
            pass
        @property
        def ZAxis(self) -> float:
            """
            :type: float
            """
        @ZAxis.setter
        def ZAxis(self, arg0: float) -> None:
            pass
        pass
    class Axes():
        """
        Members:

          kAxis_X

          kAxis_Y

          kAxis_Z
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kAxis_X': <Axes.kAxis_X: 0>, 'kAxis_Y': <Axes.kAxis_Y: 2>, 'kAxis_Z': <Axes.kAxis_Z: 4>}
        kAxis_X: wpilib._wpilib.ADXL345_I2C.Axes # value = <Axes.kAxis_X: 0>
        kAxis_Y: wpilib._wpilib.ADXL345_I2C.Axes # value = <Axes.kAxis_Y: 2>
        kAxis_Z: wpilib._wpilib.ADXL345_I2C.Axes # value = <Axes.kAxis_Z: 4>
        pass
    def __init__(self, port: I2C.Port, range: wpilib.interfaces._interfaces.Accelerometer.Range = Range.kRange_2G, deviceAddress: int = 29) -> None: 
        """
        Constructs the ADXL345 Accelerometer over I2C.

        :param port:          The I2C port the accelerometer is attached to
        :param range:         The range (+ or -) that the accelerometer will measure
        :param deviceAddress: The I2C address of the accelerometer (0x1D or 0x53)
        """
    def getAcceleration(self, axis: ADXL345_I2C.Axes) -> float: 
        """
        Get the acceleration of one axis in Gs.

        :param axis: The axis to read from.

        :returns: Acceleration of the ADXL345 in Gs.
        """
    def getAccelerations(self) -> ADXL345_I2C.AllAxes: 
        """
        Get the acceleration of all axes in Gs.

        :returns: An object containing the acceleration measured on each axis of the
                  ADXL345 in Gs.
        """
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setRange(self, range: wpilib.interfaces._interfaces.Accelerometer.Range) -> None: ...
    @property
    def _m_simDevice(self) -> hal._wpiHal.SimDevice:
        """
        :type: hal._wpiHal.SimDevice
        """
    @property
    def _m_simRange(self) -> hal._wpiHal.SimEnum:
        """
        :type: hal._wpiHal.SimEnum
        """
    @property
    def _m_simX(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    @property
    def _m_simY(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    @property
    def _m_simZ(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    _kAddress = 29
    _kDataFormatRegister = 49
    _kDataRegister = 50
    _kGsPerLSB = 0.00390625
    _kPowerCtlRegister = 45
    pass
class Field2d(Sendable):
    """
    2D representation of game field for dashboards.

    An object's pose is the location shown on the dashboard view.  Note that
    for the robot, this may or may not match the internal odometry.  For example,
    if the robot is shown at a particular starting location, the pose in this
    class would represent the actual location on the field, but the robot's
    internal state might have a 0,0,0 pose (unless it's initialized to
    something different).

    As the user is able to edit the pose, code performing updates should get
    the robot pose, transform it as appropriate (e.g. based on wheel odometry),
    and set the new pose.

    This class provides methods to set the robot pose, but other objects can
    also be shown by using the GetObject() function.  Other objects can
    also have multiple poses (which will show the object at multiple locations).
    """
    def __init__(self) -> None: ...
    def getObject(self, name: str) -> FieldObject2d: 
        """
        Get or create a field object.

        :returns: Field object
        """
    def getRobotObject(self) -> FieldObject2d: 
        """
        Get the robot object.

        :returns: Field object for robot
        """
    def getRobotPose(self) -> wpimath.geometry._geometry.Pose2d: 
        """
        Get the robot pose.

        :returns: 2D pose
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    @typing.overload
    def setRobotPose(self, pose: wpimath.geometry._geometry.Pose2d) -> None: 
        """
        Set the robot pose from a Pose object.

        :param pose: 2D pose

        Set the robot pose from x, y, and rotation.

        :param x:        X location
        :param y:        Y location
        :param rotation: rotation
        """
    @typing.overload
    def setRobotPose(self, x: meters, y: meters, rotation: wpimath.geometry._geometry.Rotation2d) -> None: ...
    pass
class FieldObject2d():
    """
    Game field object on a Field2d.
    """
    def getPose(self) -> wpimath.geometry._geometry.Pose2d: 
        """
        Get the pose.

        :returns: 2D pose, or 0,0,0 if unknown / does not exist
        """
    @typing.overload
    def getPoses(self) -> typing.List[wpimath.geometry._geometry.Pose2d]: 
        """
        Get multiple poses.

        :param obj: Object entry

        :returns: vector of 2D poses

        Get multiple poses.

        :param obj: Object entry
        :param out: output SmallVector to hold 2D poses

        :returns: ArrayRef referring to output SmallVector
        """
    @typing.overload
    def getPoses(self, out: typing.List[wpimath.geometry._geometry.Pose2d]) -> typing.List[wpimath.geometry._geometry.Pose2d]: ...
    @typing.overload
    def setPose(self, pose: wpimath.geometry._geometry.Pose2d) -> None: 
        """
        Set the pose from a Pose object.

        :param pose: 2D pose

        Set the pose from x, y, and rotation.

        :param x:        X location
        :param y:        Y location
        :param rotation: rotation
        """
    @typing.overload
    def setPose(self, x: meters, y: meters, rotation: wpimath.geometry._geometry.Rotation2d) -> None: ...
    def setPoses(self, poses: typing.List[wpimath.geometry._geometry.Pose2d]) -> None: 
        """
        Set multiple poses from an array of Pose objects.
        The total number of poses is limited to 85.

        :param poses: array of 2D poses
        """
    def setTrajectory(self, trajectory: wpimath.trajectory._trajectory.Trajectory) -> None: 
        """
        Sets poses from a trajectory.

        :param trajectory: The trajectory from which poses should be added.
        """
    pass
class ADXRS450_Gyro(GyroBase, wpilib.interfaces._interfaces.Gyro, ErrorBase, wpilib.interfaces._interfaces.PIDSource, Sendable):
    """
    Use a rate gyro to return the robots heading relative to a starting position.

    The Gyro class tracks the robots heading based on the starting position. As
    the robot rotates the new heading is computed by integrating the rate of
    rotation returned by the sensor. When the class is instantiated, it does a
    short calibration routine where it samples the gyro while at rest to
    determine the default offset. This is subtracted from each sample to
    determine the heading.

    This class is for the digital ADXRS450 gyro sensor that connects via SPI.
    Only one instance of an ADXRS Gyro is supported.
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Gyro constructor on onboard CS0.

        Gyro constructor on the specified SPI port.

        :param port: The SPI port the gyro is attached to.
        """
    @typing.overload
    def __init__(self, port: SPI.Port) -> None: ...
    def calibrate(self) -> None: 
        """
        Initialize the gyro.

        Calibrate the gyro by running for a number of samples and computing the
        center value. Then use the center value as the Accumulator center value for
        subsequent measurements.

        It's important to make sure that the robot is not moving while the
        centering calculations are in progress, this is typically done when the
        robot is first turned on while it's sitting at rest before the competition
        starts.
        """
    def getAngle(self) -> float: 
        """
        Return the actual angle in degrees that the robot is currently facing.

        The angle is based on integration of the returned rate from the gyro.
        The angle is continuous, that is it will continue from 360->361 degrees.
        This allows algorithms that wouldn't want to see a discontinuity in the
        gyro output as it sweeps from 360 to 0 on the second time around.

        :returns: the current heading of the robot in degrees.
        """
    def getPort(self) -> int: 
        """
        Get the SPI port number.

        :returns: The SPI port number.
        """
    def getRate(self) -> float: 
        """
        Return the rate of rotation of the gyro

        The rate is based on the most recent reading of the gyro.

        :returns: the current rate in degrees per second
        """
    def reset(self) -> None: 
        """
        Reset the gyro.

        Resets the gyro to a heading of zero. This can be used if there is
        significant drift in the gyro and it needs to be recalibrated after it has
        been running.
        """
    pass
class I2C(ErrorBase):
    """
    I2C bus interface class.

    This class is intended to be used by sensor (and other I2C device) drivers.
    It probably should not be used directly.
    """
    class Port():
        """
        Members:

          kOnboard

          kMXP
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kOnboard': <Port.kOnboard: 0>, 'kMXP': <Port.kMXP: 1>}
        kMXP: wpilib._wpilib.I2C.Port # value = <Port.kMXP: 1>
        kOnboard: wpilib._wpilib.I2C.Port # value = <Port.kOnboard: 0>
        pass
    def __init__(self, port: I2C.Port, deviceAddress: int) -> None: 
        """
        Constructor.

        :param port:          The I2C port to which the device is connected.
        :param deviceAddress: The address of the device on the I2C bus.
        """
    def addressOnly(self) -> bool: 
        """
        Attempt to address a device on the I2C bus.

        This allows you to figure out if there is a device on the I2C bus that
        responds to the address specified in the constructor.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    def read(self, registerAddress: int, data: buffer) -> bool: 
        """
        Execute a read transaction with the device.

        Read bytes from a device.
        Most I2C devices will auto-increment the register pointer internally
        allowing you to read consecutive registers on a device in a single
        transaction.

        :param registerAddress: The register to read first in the transaction.
        :param count:           The number of bytes to read in the transaction.
        :param buffer:          A pointer to the array of bytes to store the data
                                read from the device.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    def readOnly(self, buffer: buffer) -> bool: 
        """
        Execute a read only transaction with the device.

        Read bytes from a device. This method does not write any data to prompt the
        device.

        :param buffer: A pointer to the array of bytes to store the data read from
                       the device.
        :param count:  The number of bytes to read in the transaction.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    def transaction(self, dataToSend: buffer, dataReceived: buffer) -> bool: 
        """
        Generic transaction.

        This is a lower-level interface to the I2C hardware giving you more control
        over each transaction. If you intend to write multiple bytes in the same
        transaction and do not plan to receive anything back, use writeBulk()
        instead. Calling this with a receiveSize of 0 will result in an error.

        :param dataToSend:   Buffer of data to send as part of the transaction.
        :param sendSize:     Number of bytes to send as part of the transaction.
        :param dataReceived: Buffer to read data into.
        :param receiveSize:  Number of bytes to read from the device.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    def verifySensor(self, registerAddress: int, expected: buffer) -> bool: 
        """
        Verify that a device's registers contain expected values.

        Most devices will have a set of registers that contain a known value that
        can be used to identify them.  This allows an I2C device driver to easily
        verify that the device contains the expected value.

        @pre The device must support and be configured to use register
        auto-increment.

        :param registerAddress: The base register to start reading from the device.
        :param count:           The size of the field to be verified.
        :param expected:        A buffer containing the values expected from the
                                device.
        """
    def write(self, registerAddress: int, data: int) -> bool: 
        """
        Execute a write transaction with the device.

        Write a single byte to a register on a device and wait until the
        transaction is complete.

        :param registerAddress: The address of the register on the device to be
                                written.
        :param data:            The byte to write to the register on the device.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    def writeBulk(self, data: buffer) -> bool: 
        """
        Execute a bulk write transaction with the device.

        Write multiple bytes to a device and wait until the
        transaction is complete.

        :param data:  The data to write to the register on the device.
        :param count: The number of bytes to be written.

        :returns: Transfer Aborted... false for success, true for aborted.
        """
    pass
class DigitalInput(DigitalSource, InterruptableSensorBase, ErrorBase, Sendable):
    """
    Class to read a digital input.

    This class will read digital inputs and return the current value on the
    channel. Other devices such as encoders, gear tooth sensors, etc. that are
    implemented elsewhere will automatically allocate digital inputs and outputs
    as required. This class is only for devices like switches etc. that aren't
    implemented anywhere else.
    """
    def __init__(self, channel: int) -> None: 
        """
        Create an instance of a Digital Input class.

        Creates a digital input given a channel.

        :param channel: The DIO channel 0-9 are on-board, 10-25 are on the MXP port
        """
    def get(self) -> bool: 
        """
        Get the value from a digital input channel.

        Retrieve the value of a single digital input channel from the FPGA.
        """
    def getAnalogTriggerTypeForRouting(self) -> AnalogTriggerType: 
        """
        :returns: The type of analog trigger output to be used. 0 for Digitals
        """
    def getChannel(self) -> int: 
        """
        :returns: The GPIO channel number that this object represents.
        """
    def getPortHandleForRouting(self) -> int: 
        """
        :returns: The HAL Handle to the specified source.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isAnalogTrigger(self) -> bool: 
        """
        Is source an AnalogTrigger
        """
    def setSimDevice(self, device: int) -> None: 
        """
        Indicates this input is used by a simulated device.

        :param device: simulated device handle
        """
    pass
class RobotBase():
    """
    Implement a Robot Program framework.

    The RobotBase class is intended to be subclassed by a user creating a robot
    program. Overridden Autonomous() and OperatorControl() methods are called at
    the appropriate time as the match proceeds. In the current implementation,
    the Autonomous code will run to completion before the OperatorControl code
    could start. In the future the Autonomous code might be spawned as a task,
    then killed at the end of the Autonomous period.
    """
    def __init__(self) -> None: 
        """
        Constructor for a generic robot program.

        User code should be placed in the constructor that runs before the
        Autonomous or Operator Control period starts. The constructor will run to
        completion before Autonomous is entered.

        This must be used to ensure that the communications code starts. In the
        future it would be nice to put this code into it's own task that loads on
        boot so ensure that it runs.
        """
    def endCompetition(self) -> None: ...
    def getControlState(self) -> typing.Tuple[bool, bool, bool]: 
        """
        More efficient way to determine what state the robot is in.

        :returns: booleans representing enabled, isautonomous, istest

        .. versionadded:: 2019.2.1

        .. note:: This function only exists in RobotPy
        """
    def isAutonomous(self) -> bool: 
        """
        Determine if the robot is currently in Autonomous mode.

        :returns: True if the robot is currently operating Autonomously as determined
                  by the field controls.
        """
    def isAutonomousEnabled(self) -> bool: 
        """
        Determine if the robot is currently in Autonomous mode and enabled.

        :returns: True if the robot us currently operating Autonomously while enabled
                  as determined by the field controls.
        """
    def isDisabled(self) -> bool: 
        """
        Determine if the Robot is currently disabled.

        :returns: True if the Robot is currently disabled by the field controls.
        """
    def isEnabled(self) -> bool: 
        """
        Determine if the Robot is currently enabled.

        :returns: True if the Robot is currently enabled by the field controls.
        """
    def isNewDataAvailable(self) -> bool: 
        """
        Indicates if new data is available from the driver station.

        :returns: Has new data arrived over the network since the last time this
                  function was called?
        """
    def isOperatorControl(self) -> bool: 
        """
        Determine if the robot is currently in Operator Control mode.

        :returns: True if the robot is currently operating in Tele-Op mode as
                  determined by the field controls.
        """
    def isOperatorControlEnabled(self) -> bool: 
        """
        Determine if the robot is current in Operator Control mode and enabled.

        :returns: True if the robot is currently operating in Tele-Op mode while
                  wnabled as determined by the field-controls.
        """
    @staticmethod
    def isReal() -> bool: 
        """
        Get if the robot is real.

        :returns: If the robot is running in the real world.
        """
    @staticmethod
    def isSimulation() -> bool: 
        """
        Get if the robot is a simulation.

        :returns: If the robot is running in simulation.
        """
    def isTest(self) -> bool: 
        """
        Determine if the robot is currently in Test mode.

        :returns: True if the robot is currently running tests as determined by the
                  field controls.
        """
    @staticmethod
    def main(robot_cls: object) -> object: 
        """
        Starting point for the application
        """
    def startCompetition(self) -> None: ...
    @property
    def ds(self) -> DriverStation:
        """
        :type: DriverStation
        """
    logger: logging.Logger # value = <Logger robot (WARNING)>
    pass
class IterativeRobotBase(RobotBase):
    """
    IterativeRobotBase implements a specific type of robot program framework,
    extending the RobotBase class.

    The IterativeRobotBase class does not implement StartCompetition(), so it
    should not be used by teams directly.

    This class provides the following functions which are called by the main
    loop, StartCompetition(), at the appropriate times:

    RobotInit() -- provide for initialization at robot power-on

    Init() functions -- each of the following functions is called once when the
    appropriate mode is entered:
    - DisabledInit()   -- called each and every time disabled is entered from
    another mode
    - AutonomousInit() -- called each and every time autonomous is entered from
    another mode
    - TeleopInit()     -- called each and every time teleop is entered from
    another mode
    - TestInit()       -- called each and every time test is entered from
    another mode

    Periodic() functions -- each of these functions is called on an interval:
    - RobotPeriodic()
    - DisabledPeriodic()
    - AutonomousPeriodic()
    - TeleopPeriodic()
    - TestPeriodic()
    """
    def __init__(self, period: seconds) -> None: 
        """
        Constructor for IterativeRobotBase.

        :param period: Period.
        """
    def _loopFunc(self) -> None: ...
    def _simulationInit(self) -> None: 
        """
        Robot-wide simulation initialization code should go here.

        Users should override this method for default Robot-wide simulation
        related initialization which will be called when the robot is first
        started. It will be called exactly one time after RobotInit is called
        only when the robot is in simulation.
        """
    def _simulationPeriodic(self) -> None: 
        """
        Periodic simulation code should go here.

        This function is called in a simulated robot after user code executes.
        """
    def autonomousInit(self) -> None: 
        """
        Initialization code for autonomous mode should go here.

        Users should override this method for initialization code which will be
        called each time the robot enters autonomous mode.
        """
    def autonomousPeriodic(self) -> None: 
        """
        Periodic code for autonomous mode should go here.

        Users should override this method for code which will be called each time a
        new packet is received from the driver station and the robot is in
        autonomous mode.
        """
    def disabledInit(self) -> None: 
        """
        Initialization code for disabled mode should go here.

        Users should override this method for initialization code which will be
        called each time
        the robot enters disabled mode.
        """
    def disabledPeriodic(self) -> None: 
        """
        Periodic code for disabled mode should go here.

        Users should override this method for code which will be called each time a
        new packet is received from the driver station and the robot is in disabled
        mode.
        """
    def robotInit(self) -> None: 
        """
        Robot-wide initialization code should go here.

        Users should override this method for default Robot-wide initialization
        which will be called when the robot is first powered on. It will be called
        exactly one time.

        Warning: the Driver Station "Robot Code" light and FMS "Robot Ready"
        indicators will be off until RobotInit() exits. Code in RobotInit() that
        waits for enable will cause the robot to never indicate that the code is
        ready, causing the robot to be bypassed in a match.
        """
    def robotPeriodic(self) -> None: 
        """
        Periodic code for all modes should go here.

        This function is called each time a new packet is received from the driver
        station.
        """
    def setNetworkTablesFlushEnabled(self, enabled: bool) -> None: 
        """
        Enables or disables flushing NetworkTables every loop iteration.
        By default, this is disabled.

        :param enabled: True to enable, false to disable
        """
    def teleopInit(self) -> None: 
        """
        Initialization code for teleop mode should go here.

        Users should override this method for initialization code which will be
        called each time the robot enters teleop mode.
        """
    def teleopPeriodic(self) -> None: 
        """
        Periodic code for teleop mode should go here.

        Users should override this method for code which will be called each time a
        new packet is received from the driver station and the robot is in teleop
        mode.
        """
    def testInit(self) -> None: 
        """
        Initialization code for test mode should go here.

        Users should override this method for initialization code which will be
        called each time the robot enters test mode.
        """
    def testPeriodic(self) -> None: 
        """
        Periodic code for test mode should go here.

        Users should override this method for code which will be called each time a
        new packet is received from the driver station and the robot is in test
        mode.
        """
    @property
    def _m_period(self) -> seconds:
        """
        :type: seconds
        """
    pass
class PWM(MotorSafety, ErrorBase, Sendable):
    """
    Class implements the PWM generation in the FPGA.

    The values supplied as arguments for PWM outputs range from -1.0 to 1.0. They
    are mapped to the hardware dependent values, in this case 0-2000 for the
    FPGA. Changes are immediately sent to the FPGA, and the update occurs at the
    next FPGA cycle (5.005ms). There is no delay.

    As of revision 0.1.10 of the FPGA, the FPGA interprets the 0-2000 values as
    follows:
    - 2000 = maximum pulse width
    - 1999 to 1001 = linear scaling from "full forward" to "center"
    - 1000 = center value
    - 999 to 2 = linear scaling from "center" to "full reverse"
    - 1 = minimum pulse width (currently 0.5ms)
    - 0 = disabled (i.e. PWM output is held low)
    """
    class PeriodMultiplier():
        """
        Represents the amount to multiply the minimum servo-pulse pwm period by.

        Members:

          kPeriodMultiplier_1X : Don't skip pulses. PWM pulses occur every 5.005 ms

          kPeriodMultiplier_2X : Skip every other pulse. PWM pulses occur every 10.010 ms

          kPeriodMultiplier_4X : Skip three out of four pulses. PWM pulses occur every 20.020 ms
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kPeriodMultiplier_1X': <PeriodMultiplier.kPeriodMultiplier_1X: 1>, 'kPeriodMultiplier_2X': <PeriodMultiplier.kPeriodMultiplier_2X: 2>, 'kPeriodMultiplier_4X': <PeriodMultiplier.kPeriodMultiplier_4X: 4>}
        kPeriodMultiplier_1X: wpilib._wpilib.PWM.PeriodMultiplier # value = <PeriodMultiplier.kPeriodMultiplier_1X: 1>
        kPeriodMultiplier_2X: wpilib._wpilib.PWM.PeriodMultiplier # value = <PeriodMultiplier.kPeriodMultiplier_2X: 2>
        kPeriodMultiplier_4X: wpilib._wpilib.PWM.PeriodMultiplier # value = <PeriodMultiplier.kPeriodMultiplier_4X: 4>
        pass
    def __init__(self, channel: int) -> None: 
        """
        Allocate a PWM given a channel number.

        Checks channel value range and allocates the appropriate channel.
        The allocation is only done to help users ensure that they don't double
        assign channels.

        :param channel: The PWM channel number. 0-9 are on-board, 10-19 are on the
                        MXP port
        """
    def __repr__(self) -> str: ...
    def _initSendable(self, builder: SendableBuilder) -> None: ...
    def enableDeadbandElimination(self, eliminateDeadband: bool) -> None: 
        """
        Optionally eliminate the deadband from a speed controller.

        :param eliminateDeadband: If true, set the motor curve on the Jaguar to
                                  eliminate the deadband in the middle of the range.
                                  Otherwise, keep the full range without modifying
                                  any values.
        """
    def getChannel(self) -> int: ...
    def getDescription(self) -> str: ...
    def getPosition(self) -> float: 
        """
        Get the PWM value in terms of a position.

        This is intended to be used by servos.

        @pre SetMaxPositivePwm() called.
        @pre SetMinNegativePwm() called.

        :returns: The position the servo is set to between 0.0 and 1.0.
        """
    def getRaw(self) -> int: 
        """
        Get the PWM value directly from the hardware.

        Read a raw value from a PWM channel.

        :returns: Raw PWM control value.
        """
    def getRawBounds(self) -> typing.Tuple[int, int, int, int, int]: 
        """
        Get the bounds on the PWM values.

        This Gets the bounds on the PWM values for a particular each type of
        controller. The values determine the upper and lower speeds as well as the
        deadband bracket.

        :param max:         The Minimum pwm value
        :param deadbandMax: The high end of the deadband range
        :param center:      The center speed (off)
        :param deadbandMin: The low end of the deadband range
        :param min:         The minimum pwm value
        """
    def getSpeed(self) -> float: 
        """
        Get the PWM value in terms of speed.

        This is intended to be used by speed controllers.

        @pre SetMaxPositivePwm() called.
        @pre SetMinPositivePwm() called.
        @pre SetMaxNegativePwm() called.
        @pre SetMinNegativePwm() called.

        :returns: The most recently set speed between -1.0 and 1.0.
        """
    def setBounds(self, max: float, deadbandMax: float, center: float, deadbandMin: float, min: float) -> None: 
        """
        Set the bounds on the PWM pulse widths.

        This sets the bounds on the PWM values for a particular type of controller.
        The values determine the upper and lower speeds as well as the deadband
        bracket.

        :param max:         The max PWM pulse width in ms
        :param deadbandMax: The high end of the deadband range pulse width in ms
        :param center:      The center (off) pulse width in ms
        :param deadbandMin: The low end of the deadband pulse width in ms
        :param min:         The minimum pulse width in ms
        """
    def setDisabled(self) -> None: 
        """
        Temporarily disables the PWM output. The next set call will reenable
        the output.
        """
    def setPeriodMultiplier(self, mult: PWM.PeriodMultiplier) -> None: 
        """
        Slow down the PWM signal for old devices.

        :param mult: The period multiplier to apply to this channel
        """
    def setPosition(self, pos: float) -> None: 
        """
        Set the PWM value based on a position.

        This is intended to be used by servos.

        @pre SetMaxPositivePwm() called.
        @pre SetMinNegativePwm() called.

        :param pos: The position to set the servo between 0.0 and 1.0.
        """
    def setRaw(self, value: int) -> None: 
        """
        Set the PWM value directly to the hardware.

        Write a raw value to a PWM channel.

        :param value: Raw PWM value.
        """
    def setRawBounds(self, max: int, deadbandMax: int, center: int, deadbandMin: int, min: int) -> None: 
        """
        Set the bounds on the PWM values.

        This sets the bounds on the PWM values for a particular each type of
        controller. The values determine the upper and lower speeds as well as the
        deadband bracket.

        :param max:         The Minimum pwm value
        :param deadbandMax: The high end of the deadband range
        :param center:      The center speed (off)
        :param deadbandMin: The low end of the deadband range
        :param min:         The minimum pwm value
        """
    def setSpeed(self, speed: float) -> None: 
        """
        Set the PWM value based on a speed.

        This is intended to be used by speed controllers.

        @pre SetMaxPositivePwm() called.
        @pre SetMinPositivePwm() called.
        @pre SetCenterPwm() called.
        @pre SetMaxNegativePwm() called.
        @pre SetMinNegativePwm() called.

        :param speed: The speed to set the speed controller between -1.0 and 1.0.
        """
    def setZeroLatch(self) -> None: ...
    def stopMotor(self) -> None: ...
    pass
class Joystick(wpilib.interfaces._interfaces.GenericHID):
    """
    Handle input from standard Joysticks connected to the Driver Station.

    This class handles standard input that comes from the Driver Station. Each
    time a value is requested the most recent value is returned. There is a
    single class instance for each joystick and the mapping of ports to hardware
    buttons depends on the code in the Driver Station.
    """
    class AxisType():
        """
        Members:

          kXAxis

          kYAxis

          kZAxis

          kTwistAxis

          kThrottleAxis
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kXAxis': <AxisType.kXAxis: 0>, 'kYAxis': <AxisType.kYAxis: 1>, 'kZAxis': <AxisType.kZAxis: 2>, 'kTwistAxis': <AxisType.kTwistAxis: 3>, 'kThrottleAxis': <AxisType.kThrottleAxis: 4>}
        kThrottleAxis: wpilib._wpilib.Joystick.AxisType # value = <AxisType.kThrottleAxis: 4>
        kTwistAxis: wpilib._wpilib.Joystick.AxisType # value = <AxisType.kTwistAxis: 3>
        kXAxis: wpilib._wpilib.Joystick.AxisType # value = <AxisType.kXAxis: 0>
        kYAxis: wpilib._wpilib.Joystick.AxisType # value = <AxisType.kYAxis: 1>
        kZAxis: wpilib._wpilib.Joystick.AxisType # value = <AxisType.kZAxis: 2>
        pass
    class ButtonType():
        """
        Members:

          kTriggerButton

          kTopButton
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kTriggerButton': <ButtonType.kTriggerButton: 0>, 'kTopButton': <ButtonType.kTopButton: 1>}
        kTopButton: wpilib._wpilib.Joystick.ButtonType # value = <ButtonType.kTopButton: 1>
        kTriggerButton: wpilib._wpilib.Joystick.ButtonType # value = <ButtonType.kTriggerButton: 0>
        pass
    def __init__(self, port: int) -> None: 
        """
        Construct an instance of a joystick.

        The joystick index is the USB port on the Driver Station.

        :param port: The port on the Driver Station that the joystick is plugged
                     into (0-5).
        """
    def getDirectionDegrees(self) -> float: 
        """
        Get the direction of the vector formed by the joystick and its origin
        in degrees.

        :returns: The direction of the vector in degrees
        """
    def getDirectionRadians(self) -> float: 
        """
        Get the direction of the vector formed by the joystick and its origin
        in radians.

        :returns: The direction of the vector in radians
        """
    def getMagnitude(self) -> float: 
        """
        Get the magnitude of the direction vector formed by the joystick's
        current position relative to its origin.

        :returns: The magnitude of the direction vector
        """
    def getThrottle(self) -> float: 
        """
        Get the throttle value of the current joystick.

        This depends on the mapping of the joystick connected to the current port.
        """
    def getThrottleChannel(self) -> int: 
        """
        Get the channel currently associated with the throttle axis.

        :returns: The channel for the axis.
        """
    def getTop(self) -> bool: 
        """
        Read the state of the top button on the joystick.

        Look up which button has been assigned to the top and read its state.

        :returns: The state of the top button.
        """
    def getTopPressed(self) -> bool: 
        """
        Whether the top button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getTopReleased(self) -> bool: 
        """
        Whether the top button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getTrigger(self) -> bool: 
        """
        Read the state of the trigger on the joystick.

        Look up which button has been assigned to the trigger and read its state.

        :returns: The state of the trigger.
        """
    def getTriggerPressed(self) -> bool: 
        """
        Whether the trigger was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getTriggerReleased(self) -> bool: 
        """
        Whether the trigger was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getTwist(self) -> float: 
        """
        Get the twist value of the current joystick.

        This depends on the mapping of the joystick connected to the current port.
        """
    def getTwistChannel(self) -> int: 
        """
        Get the channel currently associated with the twist axis.

        :returns: The channel for the axis.
        """
    def getX(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand = Hand.kRightHand) -> float: 
        """
        Get the X value of the joystick.

        This depends on the mapping of the joystick connected to the current port.

        :param hand: This parameter is ignored for the Joystick class and is only
                     here to complete the GenericHID interface.
        """
    def getXChannel(self) -> int: 
        """
        Get the channel currently associated with the X axis.

        :returns: The channel for the axis.
        """
    def getY(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand = Hand.kRightHand) -> float: 
        """
        Get the Y value of the joystick.

        This depends on the mapping of the joystick connected to the current port.

        :param hand: This parameter is ignored for the Joystick class and is only
                     here to complete the GenericHID interface.
        """
    def getYChannel(self) -> int: 
        """
        Get the channel currently associated with the Y axis.

        :returns: The channel for the axis.
        """
    def getZ(self) -> float: 
        """
        Get the Z value of the current joystick.

        This depends on the mapping of the joystick connected to the current port.
        """
    def getZChannel(self) -> int: 
        """
        Get the channel currently associated with the Z axis.

        :returns: The channel for the axis.
        """
    def setThrottleChannel(self, channel: int) -> None: 
        """
        Set the channel associated with the throttle axis.

        :param axis:    The axis to set the channel for.
        :param channel: The channel to set the axis to.
        """
    def setTwistChannel(self, channel: int) -> None: 
        """
        Set the channel associated with the twist axis.

        :param axis:    The axis to set the channel for.
        :param channel: The channel to set the axis to.
        """
    def setXChannel(self, channel: int) -> None: 
        """
        Set the channel associated with the X axis.

        :param channel: The channel to set the axis to.
        """
    def setYChannel(self, channel: int) -> None: 
        """
        Set the channel associated with the Y axis.

        :param axis:    The axis to set the channel for.
        :param channel: The channel to set the axis to.
        """
    def setZChannel(self, channel: int) -> None: 
        """
        Set the channel associated with the Z axis.

        :param axis:    The axis to set the channel for.
        :param channel: The channel to set the axis to.
        """
    kDefaultThrottleChannel = 3
    kDefaultTwistChannel = 2
    kDefaultXChannel = 0
    kDefaultYChannel = 1
    kDefaultZChannel = 2
    pass
class LiveWindow():
    """
    The LiveWindow class is the public interface for putting sensors and
    actuators on the LiveWindow.
    """
    def disableAllTelemetry(self) -> None: 
        """
        Disable ALL telemetry.
        """
    def disableTelemetry(self, component: Sendable) -> None: 
        """
        Disable telemetry for a single component.

        :param sendable: component
        """
    def enableTelemetry(self, component: Sendable) -> None: 
        """
        Enable telemetry for a single component.

        :param sendable: component
        """
    @staticmethod
    def getInstance() -> LiveWindow: 
        """
        Get an instance of the LiveWindow main class.

        This is a singleton to guarantee that there is only a single instance
        regardless of how many times GetInstance is called.
        """
    def isEnabled(self) -> bool: ...
    def setEnabled(self, enabled: bool) -> None: 
        """
        Change the enabled status of LiveWindow.

        If it changes to enabled, start livewindow running otherwise stop it
        """
    def updateValues(self) -> None: 
        """
        Tell all the sensors to update (send) their values.

        Actuators are handled through callbacks on their value changing from the
        SmartDashboard widgets.
        """
    @property
    def disabled(self) -> typing.Callable[[], None]:
        """
        :type: typing.Callable[[], None]
        """
    @disabled.setter
    def disabled(self, arg0: typing.Callable[[], None]) -> None:
        pass
    @property
    def enabled(self) -> typing.Callable[[], None]:
        """
        :type: typing.Callable[[], None]
        """
    @enabled.setter
    def enabled(self, arg0: typing.Callable[[], None]) -> None:
        pass
    pass
class PWMSpeedController(PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Common base class for all PWM Speed Controllers.
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a PWM Speed Controller connected via PWM.

        :param channel: The PWM channel that the controller is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    def _initSendable(self, builder: SendableBuilder) -> None: ...
    def disable(self) -> None: ...
    def get(self) -> float: 
        """
        Get the recently set value of the PWM. This value is affected by the
        inversion property. If you want the value that is sent directly to the
        SpeedController, use :meth:`.PWM.getSpeed` instead.

        :returns: The most recently set value for the PWM between -1.0 and 1.0.
        """
    def getInverted(self) -> bool: ...
    def pidWrite(self, output: float) -> None: 
        """
        Write out the PID value as seen in the PIDOutput base object.

        :param output: Write out the PWM value as was found in the PIDController
        """
    def set(self, value: float) -> None: 
        """
        Set the PWM value.

        The PWM value is set using a range of -1.0 to 1.0, appropriately scaling
        the value for the FPGA.

        :param speed: The speed value between -1.0 and 1.0 to set.
        """
    def setInverted(self, isInverted: bool) -> None: ...
    def stopMotor(self) -> None: ...
    pass
class NidecBrushless(wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput, MotorSafety, ErrorBase, Sendable):
    """
    Nidec Brushless Motor.
    """
    def __init__(self, pwmChannel: int, dioChannel: int) -> None: 
        """
        Constructor.

        :param pwmChannel: The PWM channel that the Nidec Brushless controller is
                           attached to. 0-9 are on-board, 10-19 are on the MXP port.
        :param dioChannel: The DIO channel that the Nidec Brushless controller is
                           attached to. 0-9 are on-board, 10-25 are on the MXP port.
        """
    def disable(self) -> None: 
        """
        Disable the motor. The Enable() function must be called to re-enable the
        motor.
        """
    def enable(self) -> None: 
        """
        Re-enable the motor after Disable() has been called. The Set() function
        must be called to set a new motor speed.
        """
    def get(self) -> float: 
        """
        Get the recently set value of the PWM.

        :returns: The most recently set value for the PWM between -1.0 and 1.0.
        """
    def getChannel(self) -> int: 
        """
        Gets the channel number associated with the object.

        :returns: The channel number.
        """
    def getDescription(self) -> str: ...
    def getInverted(self) -> bool: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidWrite(self, output: float) -> None: 
        """
        Write out the PID value as seen in the PIDOutput base object.

        :param output: Write out the PWM value as was found in the PIDController
        """
    def set(self, speed: float) -> None: 
        """
        Set the PWM value.

        The PWM value is set using a range of -1.0 to 1.0, appropriately scaling
        the value for the FPGA.

        :param speed: The speed value between -1.0 and 1.0 to set.
        """
    def setInverted(self, isInverted: bool) -> None: ...
    def stopMotor(self) -> None: ...
    pass
class Notifier(ErrorBase):
    def __init__(self, handler: typing.Callable[[], None]) -> None: 
        """
        Create a Notifier for timer event notification.

        :param handler: The handler is called at the notification time which is set
                        using StartSingle or StartPeriodic.
        """
    def setHandler(self, handler: typing.Callable[[], None]) -> None: 
        """
        Change the handler function.

        :param handler: Handler
        """
    def setName(self, name: str) -> None: 
        """
        Sets the name of the notifier.  Used for debugging purposes only.

        :param name: Name
        """
    def startPeriodic(self, period: seconds) -> None: 
        """
        Register for periodic event notification.

        A timer event is queued for periodic event notification. Each time the
        interrupt occurs, the event will be immediately requeued for the same time
        interval.

        :param period: Period to call the handler starting one period
                       after the call to this method.
        """
    def startSingle(self, delay: seconds) -> None: 
        """
        Register for single event notification.

        A timer event is queued for a single event after the specified delay.

        :param delay: Amount of time to wait before the handler is called.
        """
    def stop(self) -> None: 
        """
        Stop timer events from occurring.

        Stop any repeating timer events from occurring. This will also remove any
        single notification events from the queue.

        If a timer-based call to the registered handler is in progress, this
        function will block until the handler call is complete.
        """
    pass
class Jaguar(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Luminary Micro / Vex Robotics Jaguar Speed Controller with PWM control.

    Note that the Jaguar uses the following bounds for PWM values. These values
    should work reasonably well for most controllers, but if users experience
    issues such as asymmetric behavior around the deadband or inability to
    saturate the controller in either direction, calibration is recommended. The
    calibration procedure can be found in the Jaguar User Manual available from
    Vex.

    - 2.310ms = full "forward"
    - 1.550ms = the "high end" of the deadband range
    - 1.507ms = center of the deadband range (off)
    - 1.454ms = the "low end" of the deadband range
    - 0.697ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a Jaguar connected via PWM.

        :param channel: The PWM channel that the Jaguar is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class PWMSparkMax(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    REV Robotics SPARK MAX Speed Controller.

    Note that the SPARK MAX uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the SPARK MAX User
    Manual available from REV Robotics.

    - 2.003ms = full "forward"
    - 1.550ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.460ms = the "low end" of the deadband range
    - 0.999ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a SPARK MAX.

        :param channel: The PWM channel that the SPARK MAX is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class DMC60(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Digilent DMC 60 Speed Controller.

    Note that the DMC 60 uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the DMC 60 User
    Manual available from Digilent.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a Digilent DMC 60.

        :param channel: The PWM channel that the DMC 60 is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class PWMTalonFX(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Cross the Road Electronics (CTRE) Talon FX Speed Controller with PWM
    control.

    Note that the Talon FX uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the Talon FX User
    Manual available from Cross The Road Electronics.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct a Talon FX connected via PWM.

        :param channel: The PWM channel that the Talon FX is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class PWMTalonSRX(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Cross the Road Electronics (CTRE) Talon SRX Speed Controller with PWM
    control.

    Note that the Talon SRX uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the Talon SRX User
    Manual available from Cross The Road Electronics.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct a Talon SRX connected via PWM.

        :param channel: The PWM channel that the Talon SRX is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class PWMVenom(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Playing with Fusion Venom Smart Motor with PWM control.

    Note that the Venom uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct a Venom connected via PWM.

        :param channel: The PWM channel that the Venom is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class PWMVictorSPX(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Cross the Road Electronics (CTRE) Victor SPX Speed Controller with PWM
    control.

    Note that the Victor SPX uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the Victor SPX User
    Manual available from Cross The Road Electronics.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Construct a Victor SPX connected via PWM.

        :param channel: The PWM channel that the Victor SPX is attached to. 0-9
                        are on-board, 10-19 are on the MXP port
        """
    pass
class PowerDistributionPanel(ErrorBase, Sendable):
    """
    Class for getting voltage, current, temperature, power and energy from the
    CAN PDP.
    """
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, module: int) -> None: ...
    def clearStickyFaults(self) -> None: 
        """
        Remove all of the fault flags on the PDP.
        """
    def getCurrent(self, channel: int) -> float: 
        """
        Query the current of a single channel of the PDP.

        :returns: The current of one of the PDP channels (channels 0-15) in Amperes
        """
    def getModule(self) -> int: 
        """
        Gets module number (CAN ID).
        """
    def getTemperature(self) -> float: 
        """
        Query the temperature of the PDP.

        :returns: The temperature of the PDP in degrees Celsius
        """
    def getTotalCurrent(self) -> float: 
        """
        Query the total current of all monitored PDP channels (0-15).

        :returns: The the total current drawn from the PDP channels in Amperes
        """
    def getTotalEnergy(self) -> float: 
        """
        Query the total energy drawn from the monitored PDP channels.

        :returns: The the total energy drawn from the PDP channels in Joules
        """
    def getTotalPower(self) -> float: 
        """
        Query the total power drawn from the monitored PDP channels.

        :returns: The the total power drawn from the PDP channels in Watts
        """
    def getVoltage(self) -> float: 
        """
        Query the input voltage of the PDP.

        :returns: The voltage of the PDP in volts
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def resetTotalEnergy(self) -> None: 
        """
        Reset the total energy drawn from the PDP.

        @see PowerDistributionPanel#GetTotalEnergy
        """
    pass
class Preferences():
    """
    The preferences class provides a relatively simple way to save important
    values to the roboRIO to access the next time the roboRIO is booted.

    This class loads and saves from a file inside the roboRIO.  The user cannot
    access the file directly, but may modify values at specific fields which will
    then be automatically periodically saved to the file by the NetworkTable
    server.

    This class is thread safe.

    This will also interact with {@link NetworkTable} by creating a table called
    "Preferences" with all the key-value pairs.
    """
    def containsKey(self, key: str) -> bool: 
        """
        Returns whether or not there is a key with the given name.

        :param key: the key

        :returns: if there is a value at the given key
        """
    def getBoolean(self, key: str, defaultValue: bool = False) -> bool: 
        """
        Returns the boolean at the given key.  If this table does not have a value
        for that position, then the given defaultValue value will be returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    def getDouble(self, key: str, defaultValue: float = 0.0) -> float: 
        """
        Returns the double at the given key.  If this table does not have a value
        for that position, then the given defaultValue value will be returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    def getFloat(self, key: str, defaultValue: float = 0.0) -> float: 
        """
        Returns the float at the given key.  If this table does not have a value
        for that position, then the given defaultValue value will be returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    @staticmethod
    def getInstance() -> Preferences: 
        """
        Get the one and only {@link Preferences} object.

        :returns: pointer to the {@link Preferences}
        """
    def getInt(self, key: str, defaultValue: int = 0) -> int: 
        """
        Returns the int at the given key.  If this table does not have a value for
        that position, then the given defaultValue value will be returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    def getKeys(self) -> typing.List[str]: 
        """
        Returns a vector of all the keys.

        :returns: a vector of the keys
        """
    def getLong(self, key: str, defaultValue: int = 0) -> int: 
        """
        Returns the long (int64_t) at the given key.  If this table does not have a
        value for that position, then the given defaultValue value will be
        returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    def getString(self, key: str, defaultValue: str = '') -> str: 
        """
        Returns the string at the given key.  If this table does not have a value
        for that position, then the given defaultValue will be returned.

        :param key:          the key
        :param defaultValue: the value to return if none exists in the table

        :returns: either the value in the table, or the defaultValue
        """
    def initBoolean(self, key: str, value: bool) -> None: 
        """
        Puts the given boolean into the preferences table if it doesn't
        already exist.
        """
    def initDouble(self, key: str, value: float) -> None: 
        """
        Puts the given double into the preferences table if it doesn't
        already exist.
        """
    def initFloat(self, key: str, value: float) -> None: 
        """
        Puts the given float into the preferences table if it doesn't
        already exist.
        """
    def initInt(self, key: str, value: int) -> None: 
        """
        Puts the given int into the preferences table if it doesn't
        already exist.
        """
    def initLong(self, key: str, value: int) -> None: 
        """
        Puts the given long into the preferences table if it doesn't
        already exist.
        """
    def initString(self, key: str, value: str) -> None: 
        """
        Puts the given string into the preferences table if it doesn't
        already exist.
        """
    def putBoolean(self, key: str, value: bool) -> None: 
        """
        Puts the given boolean into the preferences table.

        The key may not have any whitespace nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def putDouble(self, key: str, value: float) -> None: 
        """
        Puts the given double into the preferences table.

        The key may not have any whitespace nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def putFloat(self, key: str, value: float) -> None: 
        """
        Puts the given float into the preferences table.

        The key may not have any whitespace nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def putInt(self, key: str, value: int) -> None: 
        """
        Puts the given int into the preferences table.

        The key may not have any whitespace nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def putLong(self, key: str, value: int) -> None: 
        """
        Puts the given long (int64_t) into the preferences table.

        The key may not have any whitespace nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def putString(self, key: str, value: str) -> None: 
        """
        Puts the given string into the preferences table.

        The value may not have quotation marks, nor may the key have any whitespace
        nor an equals sign.

        :param key:   the key
        :param value: the value
        """
    def remove(self, key: str) -> None: 
        """
        Remove a preference.

        :param key: the key
        """
    def removeAll(self) -> None: 
        """
        Remove all preferences.
        """
    pass
class Relay(MotorSafety, ErrorBase, Sendable):
    """
    Class for Spike style relay outputs.

    Relays are intended to be connected to spikes or similar relays. The relay
    channels controls a pair of pins that are either both off, one on, the other
    on, or both on. This translates into two spike outputs at 0v, one at 12v and
    one at 0v, one at 0v and the other at 12v, or two spike outputs at 12V. This
    allows off, full forward, or full reverse control of motors without variable
    speed. It also allows the two channels (forward and reverse) to be used
    independently for something that does not care about voltage polarity (like
    a solenoid).
    """
    class Direction():
        """
        Members:

          kBothDirections

          kForwardOnly

          kReverseOnly
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kBothDirections': <Direction.kBothDirections: 0>, 'kForwardOnly': <Direction.kForwardOnly: 1>, 'kReverseOnly': <Direction.kReverseOnly: 2>}
        kBothDirections: wpilib._wpilib.Relay.Direction # value = <Direction.kBothDirections: 0>
        kForwardOnly: wpilib._wpilib.Relay.Direction # value = <Direction.kForwardOnly: 1>
        kReverseOnly: wpilib._wpilib.Relay.Direction # value = <Direction.kReverseOnly: 2>
        pass
    class Value():
        """
        Members:

          kOff

          kOn

          kForward

          kReverse
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kOff': <Value.kOff: 0>, 'kOn': <Value.kOn: 1>, 'kForward': <Value.kForward: 2>, 'kReverse': <Value.kReverse: 3>}
        kForward: wpilib._wpilib.Relay.Value # value = <Value.kForward: 2>
        kOff: wpilib._wpilib.Relay.Value # value = <Value.kOff: 0>
        kOn: wpilib._wpilib.Relay.Value # value = <Value.kOn: 1>
        kReverse: wpilib._wpilib.Relay.Value # value = <Value.kReverse: 3>
        pass
    def __init__(self, channel: int, direction: Relay.Direction = Direction.kBothDirections) -> None: 
        """
        Relay constructor given a channel.

        This code initializes the relay and reserves all resources that need to be
        locked. Initially the relay is set to both lines at 0v.

        :param channel:   The channel number (0-3).
        :param direction: The direction that the Relay object will control.
        """
    def __repr__(self) -> str: ...
    def get(self) -> Relay.Value: 
        """
        Get the Relay State

        Gets the current state of the relay.

        When set to kForwardOnly or kReverseOnly, value is returned as kOn/kOff not
        kForward/kReverse (per the recommendation in Set).

        :returns: The current state of the relay as a Relay::Value
        """
    def getChannel(self) -> int: ...
    def getDescription(self) -> str: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def set(self, value: Relay.Value) -> None: 
        """
        Set the relay state.

        Valid values depend on which directions of the relay are controlled by the
        object.

        When set to kBothDirections, the relay can be any of the four states:
        0v-0v, 0v-12v, 12v-0v, 12v-12v

        When set to kForwardOnly or kReverseOnly, you can specify the constant for
        the direction or you can simply specify kOff and kOn.  Using only kOff and
        kOn is recommended.

        :param value: The state to set the relay.
        """
    def stopMotor(self) -> None: ...
    pass
class IterativeRobot(IterativeRobotBase, RobotBase):
    """
    IterativeRobot implements the IterativeRobotBase robot program framework.

    The IterativeRobot class is intended to be subclassed by a user creating a
    robot program.

    Periodic() functions from the base class are called each time a new packet is
    received from the driver station.

    :deprecated: Use TimedRobot instead. It's a drop-in replacement that provides
                 more regular execution periods.
    """
    def __init__(self) -> None: ...
    def endCompetition(self) -> None: 
        """
        Ends the main loop in StartCompetition().
        """
    def startCompetition(self) -> None: 
        """
        Provide an alternate "main loop" via StartCompetition().

        This specific StartCompetition() implements "main loop" behavior synced
        with the DS packets.
        """
    pass
class RobotController():
    @staticmethod
    def getBatteryVoltage() -> volts: 
        """
        Read the battery voltage.

        :returns: The battery voltage in Volts.
        """
    @staticmethod
    def getCANStatus() -> CANStatus: ...
    @staticmethod
    def getCurrent3V3() -> float: 
        """
        Get the current output of the 3.3V rail.

        :returns: The controller 3.3V rail output current value in Amps
        """
    @staticmethod
    def getCurrent5V() -> float: 
        """
        Get the current output of the 5V rail.

        :returns: The controller 5V rail output current value in Amps
        """
    @staticmethod
    def getCurrent6V() -> float: 
        """
        Get the current output of the 6V rail.

        :returns: The controller 6V rail output current value in Amps
        """
    @staticmethod
    def getEnabled3V3() -> bool: 
        """
        Get the enabled state of the 3.3V rail. The rail may be disabled due to a
        controller brownout, a short circuit on the rail, or controller
        over-voltage.

        :returns: The controller 3.3V rail enabled value. True for enabled.
        """
    @staticmethod
    def getEnabled5V() -> bool: 
        """
        Get the enabled state of the 5V rail. The rail may be disabled due to a
        controller brownout, a short circuit on the rail, or controller
        over-voltage.

        :returns: The controller 5V rail enabled value. True for enabled.
        """
    @staticmethod
    def getEnabled6V() -> bool: 
        """
        Get the enabled state of the 6V rail. The rail may be disabled due to a
        controller brownout, a short circuit on the rail, or controller
        over-voltage.

        :returns: The controller 6V rail enabled value. True for enabled.
        """
    @staticmethod
    def getFPGARevision() -> int: 
        """
        Return the FPGA Revision number.

        The format of the revision is 3 numbers. The 12 most significant bits are
        the Major Revision. The next 8 bits are the Minor Revision. The 12 least
        significant bits are the Build Number.

        :returns: FPGA Revision number.
        """
    @staticmethod
    def getFPGATime() -> int: 
        """
        Read the microsecond-resolution timer on the FPGA.

        :returns: The current time in microseconds according to the FPGA (since FPGA
                  reset).
        """
    @staticmethod
    def getFPGAVersion() -> int: 
        """
        Return the FPGA Version number.

        For now, expect this to be competition year.

        :returns: FPGA Version number.
        """
    @staticmethod
    def getFaultCount3V3() -> int: 
        """
        Get the count of the total current faults on the 3.3V rail since the
        controller has booted.

        :returns: The number of faults
        """
    @staticmethod
    def getFaultCount5V() -> int: 
        """
        Get the count of the total current faults on the 5V rail since the
        controller has booted.

        :returns: The number of faults
        """
    @staticmethod
    def getFaultCount6V() -> int: 
        """
        Get the count of the total current faults on the 6V rail since the
        controller has booted.

        :returns: The number of faults.
        """
    @staticmethod
    def getInputCurrent() -> float: 
        """
        Get the input current to the robot controller.

        :returns: The controller input current value in Amps
        """
    @staticmethod
    def getInputVoltage() -> float: 
        """
        Get the input voltage to the robot controller.

        :returns: The controller input voltage value in Volts
        """
    @staticmethod
    def getUserButton() -> bool: 
        """
        Get the state of the "USER" button on the roboRIO.

        :returns: True if the button is currently pressed down
        """
    @staticmethod
    def getVoltage3V3() -> float: 
        """
        Get the voltage of the 3.3V rail.

        :returns: The controller 3.3V rail voltage value in Volts
        """
    @staticmethod
    def getVoltage5V() -> float: 
        """
        Get the voltage of the 5V rail.

        :returns: The controller 5V rail voltage value in Volts
        """
    @staticmethod
    def getVoltage6V() -> float: 
        """
        Get the voltage of the 6V rail.

        :returns: The controller 6V rail voltage value in Volts
        """
    @staticmethod
    def isBrownedOut() -> bool: 
        """
        Check if the system is browned out.

        :returns: True if the system is browned out
        """
    @staticmethod
    def isSysActive() -> bool: 
        """
        Check if the FPGA outputs are enabled.

        The outputs may be disabled if the robot is disabled or e-stopped, the
        watchdog has expired, or if the roboRIO browns out.

        :returns: True if the FPGA outputs are enabled.
        """
    pass
class RobotState():
    @staticmethod
    def isAutonomous() -> bool: ...
    @staticmethod
    def isDisabled() -> bool: ...
    @staticmethod
    def isEStopped() -> bool: ...
    @staticmethod
    def isEnabled() -> bool: ...
    @staticmethod
    def isOperatorControl() -> bool: ...
    @staticmethod
    def isTest() -> bool: ...
    pass
class SD540(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Mindsensors SD540 Speed Controller.

    Note that the SD540 uses the following bounds for PWM values. These values
    should work reasonably well for most controllers, but if users experience
    issues such as asymmetric behavior around the deadband or inability to
    saturate the controller in either direction, calibration is recommended.
    The calibration procedure can be found in the SD540 User Manual available
    from Mindsensors.

    - 2.05ms = full "forward"
    - 1.55ms = the "high end" of the deadband range
    - 1.50ms = center of the deadband range (off)
    - 1.44ms = the "low end" of the deadband range
    - 0.94ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a SD540.

        :param channel: The PWM channel that the SD540 is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class SPI(ErrorBase):
    """
    SPI bus interface class.

    This class is intended to be used by sensor (and other SPI device) drivers.
    It probably should not be used directly.
    """
    class Port():
        """
        Members:

          kOnboardCS0

          kOnboardCS1

          kOnboardCS2

          kOnboardCS3

          kMXP
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kOnboardCS0': <Port.kOnboardCS0: 0>, 'kOnboardCS1': <Port.kOnboardCS1: 1>, 'kOnboardCS2': <Port.kOnboardCS2: 2>, 'kOnboardCS3': <Port.kOnboardCS3: 3>, 'kMXP': <Port.kMXP: 4>}
        kMXP: wpilib._wpilib.SPI.Port # value = <Port.kMXP: 4>
        kOnboardCS0: wpilib._wpilib.SPI.Port # value = <Port.kOnboardCS0: 0>
        kOnboardCS1: wpilib._wpilib.SPI.Port # value = <Port.kOnboardCS1: 1>
        kOnboardCS2: wpilib._wpilib.SPI.Port # value = <Port.kOnboardCS2: 2>
        kOnboardCS3: wpilib._wpilib.SPI.Port # value = <Port.kOnboardCS3: 3>
        pass
    def __init__(self, port: SPI.Port) -> None: 
        """
        Constructor

        :param port: the physical SPI port
        """
    def configureAutoStall(self, port: hal._wpiHal.SPIPort, csToSclkTicks: int, stallTicks: int, pow2BytesPerRead: int) -> None: 
        """
        Configure the Auto SPI Stall time between reads.

        :param port:             The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for
                                 MXP.
        :param csToSclkTicks:    the number of ticks to wait before asserting the cs
                                 pin
        :param stallTicks:       the number of ticks to stall for
        :param pow2BytesPerRead: the number of bytes to read before stalling
        """
    def forceAutoRead(self) -> None: 
        """
        Force the engine to make a single transfer.
        """
    def freeAccumulator(self) -> None: 
        """
        Frees the accumulator.
        """
    def freeAuto(self) -> None: 
        """
        Frees the automatic SPI transfer engine.
        """
    def getAccumulatorAverage(self) -> float: 
        """
        Read the average of the accumulated value.

        :returns: The accumulated average value (value / count).
        """
    def getAccumulatorCount(self) -> int: 
        """
        Read the number of accumulated values.

        Read the count of the accumulated values since the accumulator was last
        Reset().

        :returns: The number of times samples from the channel were accumulated.
        """
    def getAccumulatorIntegratedAverage(self) -> float: 
        """
        Read the average of the integrated value.  This is the sum of (each value
        times the time between values), divided by the count.

        :returns: The average of the integrated value accumulated since the last
                  Reset().
        """
    def getAccumulatorIntegratedValue(self) -> float: 
        """
        Read the integrated value.  This is the sum of (each value * time between
        values).

        :returns: The integrated value accumulated since the last Reset().
        """
    def getAccumulatorLastValue(self) -> int: 
        """
        Read the last value read by the accumulator engine.
        """
    def getAccumulatorOutput(self) -> typing.Tuple[int, int]: 
        """
        Read the accumulated value and the number of accumulated values atomically.

        This function reads the value and count atomically.
        This can be used for averaging.

        :param value: Pointer to the 64-bit accumulated output.
        :param count: Pointer to the number of accumulation cycles.
        """
    def getAccumulatorValue(self) -> int: 
        """
        Read the accumulated value.

        :returns: The 64-bit value accumulated since the last Reset().
        """
    def getAutoDroppedCount(self) -> int: 
        """
        Get the number of bytes dropped by the automatic SPI transfer engine due
        to the receive buffer being full.

        :returns: Number of bytes dropped
        """
    def initAccumulator(self, period: seconds, cmd: int, xferSize: int, validMask: int, validValue: int, dataShift: int, dataSize: int, isSigned: bool, bigEndian: bool) -> None: 
        """
        Initialize the accumulator.

        :param period:    Time between reads
        :param cmd:       SPI command to send to request data
        :param xferSize:  SPI transfer size, in bytes
        :param validMask: Mask to apply to received data for validity checking
        :param validData: After valid_mask is applied, required matching value for
                          validity checking
        :param dataShift: Bit shift to apply to received data to get actual data
                          value
        :param dataSize:  Size (in bits) of data field
        :param isSigned:  Is data field signed?
        :param bigEndian: Is device big endian?
        """
    def initAuto(self, bufferSize: int) -> None: 
        """
        Initialize automatic SPI transfer engine.

        Only a single engine is available, and use of it blocks use of all other
        chip select usage on the same physical SPI port while it is running.

        :param bufferSize: buffer size in bytes
        """
    def read(self, initiate: bool, dataReceived: buffer) -> int: 
        """
        Read a word from the receive FIFO.

        Waits for the current transfer to complete if the receive FIFO is empty.

        If the receive FIFO is empty, there is no active transfer, and initiate
        is false, errors.

        :param initiate: If true, this function pushes "0" into the transmit buffer
                         and initiates a transfer. If false, this function assumes
                         that data is already in the receive FIFO from a previous
                         write.
        """
    def readAutoReceivedData(self, buffer: buffer, timeout: seconds) -> int: 
        """
        Read data that has been transferred by the automatic SPI transfer engine.

        Transfers may be made a byte at a time, so it's necessary for the caller
        to handle cases where an entire transfer has not been completed.

        Each received data sequence consists of a timestamp followed by the
        received data bytes, one byte per word (in the least significant byte).
        The length of each received data sequence is the same as the combined
        size of the data and zeroSize set in SetAutoTransmitData().

        Blocks until numToRead words have been read or timeout expires.
        May be called with numToRead=0 to retrieve how many words are available.

        :param buffer:    buffer where read words are stored
        :param numToRead: number of words to read
        :param timeout:   timeout (ms resolution)

        :returns: Number of words remaining to be read
        """
    def resetAccumulator(self) -> None: 
        """
        Resets the accumulator to zero.
        """
    def setAccumulatorCenter(self, center: int) -> None: 
        """
        Set the center value of the accumulator.

        The center value is subtracted from each value before it is added to the
        accumulator. This is used for the center value of devices like gyros and
        accelerometers to make integration work and to take the device offset into
        account when integrating.
        """
    def setAccumulatorDeadband(self, deadband: int) -> None: 
        """
        Set the accumulator's deadband.
        """
    def setAccumulatorIntegratedCenter(self, center: float) -> None: 
        """
        Set the center value of the accumulator integrator.

        The center value is subtracted from each value*dt before it is added to the
        integrated value. This is used for the center value of devices like gyros
        and accelerometers to take the device offset into account when integrating.
        """
    def setAutoTransmitData(self, dataToSend: typing.List[int], zeroSize: int) -> None: 
        """
        Set the data to be transmitted by the engine.

        Up to 16 bytes are configurable, and may be followed by up to 127 zero
        bytes.

        :param dataToSend: data to send (maximum 16 bytes)
        :param zeroSize:   number of zeros to send after the data
        """
    def setChipSelectActiveHigh(self) -> None: 
        """
        Configure the chip select line to be active high.
        """
    def setChipSelectActiveLow(self) -> None: 
        """
        Configure the chip select line to be active low.
        """
    def setClockActiveHigh(self) -> None: 
        """
        Configure the clock output line to be active high.
        This is sometimes called clock polarity low or clock idle low.
        """
    def setClockActiveLow(self) -> None: 
        """
        Configure the clock output line to be active low.
        This is sometimes called clock polarity high or clock idle high.
        """
    def setClockRate(self, hz: int) -> None: 
        """
        Configure the rate of the generated clock signal.

        The default value is 500,000Hz.
        The maximum value is 4,000,000Hz.

        :param hz: The clock rate in Hertz.
        """
    def setLSBFirst(self) -> None: 
        """
        Configure the order that bits are sent and received on the wire
        to be least significant bit first.
        """
    def setMSBFirst(self) -> None: 
        """
        Configure the order that bits are sent and received on the wire
        to be most significant bit first.
        """
    def setSampleDataOnFalling(self) -> None: ...
    def setSampleDataOnLeadingEdge(self) -> None: 
        """
        Configure that the data is stable on the leading edge and the data
        changes on the trailing edge.
        """
    def setSampleDataOnRising(self) -> None: ...
    def setSampleDataOnTrailingEdge(self) -> None: 
        """
        Configure that the data is stable on the trailing edge and the data
        changes on the leading edge.
        """
    def startAutoRate(self, period: seconds) -> None: 
        """
        Start running the automatic SPI transfer engine at a periodic rate.

        :param period: period between transfers (us resolution)
        """
    def startAutoTrigger(self, source: DigitalSource, rising: bool, falling: bool) -> None: 
        """
        Start running the automatic SPI transfer engine when a trigger occurs.

        :param source:  digital source for the trigger (may be an analog trigger)
        :param rising:  trigger on the rising edge
        :param falling: trigger on the falling edge
        """
    def stopAuto(self) -> None: 
        """
        Stop running the automatic SPI transfer engine.
        """
    def transaction(self, dataToSend: buffer, dataReceived: buffer) -> int: 
        """
        Perform a simultaneous read/write transaction with the device

        :param dataToSend:   The data to be written out to the device
        :param dataReceived: Buffer to receive data from the device
        :param size:         The length of the transaction, in bytes
        """
    def write(self, data: buffer) -> int: 
        """
        Write data to the peripheral device.  Blocks until there is space in the
        output FIFO.

        If not running in output only mode, also saves the data received
        on the CIPO input during the transfer into the receive FIFO.
        """
    @property
    def _m_clockIdleHigh(self) -> bool:
        """
        :type: bool
        """
    @_m_clockIdleHigh.setter
    def _m_clockIdleHigh(self, arg0: bool) -> None:
        pass
    @property
    def _m_msbFirst(self) -> bool:
        """
        :type: bool
        """
    @_m_msbFirst.setter
    def _m_msbFirst(self, arg0: bool) -> None:
        pass
    @property
    def _m_sampleOnTrailing(self) -> bool:
        """
        :type: bool
        """
    @_m_sampleOnTrailing.setter
    def _m_sampleOnTrailing(self, arg0: bool) -> None:
        pass
    pass
class ADXL345_SPI(ErrorBase, wpilib.interfaces._interfaces.Accelerometer, Sendable):
    """
    ADXL345 Accelerometer on SPI.

    This class allows access to an Analog Devices ADXL345 3-axis accelerometer
    via SPI. This class assumes the sensor is wired in 4-wire SPI mode.
    """
    class AllAxes():
        def __init__(self) -> None: ...
        @property
        def XAxis(self) -> float:
            """
            :type: float
            """
        @XAxis.setter
        def XAxis(self, arg0: float) -> None:
            pass
        @property
        def YAxis(self) -> float:
            """
            :type: float
            """
        @YAxis.setter
        def YAxis(self, arg0: float) -> None:
            pass
        @property
        def ZAxis(self) -> float:
            """
            :type: float
            """
        @ZAxis.setter
        def ZAxis(self, arg0: float) -> None:
            pass
        pass
    class Axes():
        """
        Members:

          kAxis_X

          kAxis_Y

          kAxis_Z
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kAxis_X': <Axes.kAxis_X: 0>, 'kAxis_Y': <Axes.kAxis_Y: 2>, 'kAxis_Z': <Axes.kAxis_Z: 4>}
        kAxis_X: wpilib._wpilib.ADXL345_SPI.Axes # value = <Axes.kAxis_X: 0>
        kAxis_Y: wpilib._wpilib.ADXL345_SPI.Axes # value = <Axes.kAxis_Y: 2>
        kAxis_Z: wpilib._wpilib.ADXL345_SPI.Axes # value = <Axes.kAxis_Z: 4>
        pass
    def __init__(self, port: SPI.Port, range: wpilib.interfaces._interfaces.Accelerometer.Range = Range.kRange_2G) -> None: 
        """
        Constructor.

        :param port:  The SPI port the accelerometer is attached to
        :param range: The range (+ or -) that the accelerometer will measure
        """
    def getAcceleration(self, axis: ADXL345_SPI.Axes) -> float: 
        """
        Get the acceleration of one axis in Gs.

        :param axis: The axis to read from.

        :returns: Acceleration of the ADXL345 in Gs.
        """
    def getAccelerations(self) -> ADXL345_SPI.AllAxes: 
        """
        Get the acceleration of all axes in Gs.

        :returns: An object containing the acceleration measured on each axis of the
                  ADXL345 in Gs.
        """
    def getX(self) -> float: ...
    def getY(self) -> float: ...
    def getZ(self) -> float: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setRange(self, range: wpilib.interfaces._interfaces.Accelerometer.Range) -> None: ...
    @property
    def _m_simDevice(self) -> hal._wpiHal.SimDevice:
        """
        :type: hal._wpiHal.SimDevice
        """
    @property
    def _m_simRange(self) -> hal._wpiHal.SimEnum:
        """
        :type: hal._wpiHal.SimEnum
        """
    @property
    def _m_simX(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    @property
    def _m_simY(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    @property
    def _m_simZ(self) -> hal._wpiHal.SimDouble:
        """
        :type: hal._wpiHal.SimDouble
        """
    _kDataFormatRegister = 49
    _kDataRegister = 50
    _kGsPerLSB = 0.00390625
    _kPowerCtlRegister = 45
    pass
class SendableBase(Sendable):
    pass
class SendableBuilder():
    def __init__(self) -> None: ...
    def addBooleanArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[int]], setter: typing.Callable[[typing.List[int]], None]) -> None: 
        """
        Add a boolean array property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addBooleanProperty(self, key: str, getter: typing.Callable[[], bool], setter: typing.Callable[[bool], None]) -> None: 
        """
        Add a boolean property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addDoubleArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[float]], setter: typing.Callable[[typing.List[float]], None]) -> None: 
        """
        Add a double array property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addDoubleProperty(self, key: str, getter: typing.Callable[[], float], setter: typing.Callable[[float], None]) -> None: 
        """
        Add a double property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addRawProperty(self, key: str, getter: typing.Callable[[], str], setter: typing.Callable[[str], None]) -> None: 
        """
        Add a raw property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addSmallBooleanArrayProperty(self, key: str, getter: typing.Callable[[typing.List[int]], typing.List[int]], setter: typing.Callable[[typing.List[int]], None]) -> None: 
        """
        Add a boolean array property (SmallVector form).

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addSmallDoubleArrayProperty(self, key: str, getter: typing.Callable[[typing.List[float]], typing.List[float]], setter: typing.Callable[[typing.List[float]], None]) -> None: 
        """
        Add a double array property (SmallVector form).

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addSmallRawProperty(self, key: str, getter: typing.Callable[[typing.List[str]], str], setter: typing.Callable[[str], None]) -> None: 
        """
        Add a raw property (SmallVector form).

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addSmallStringArrayProperty(self, key: str, getter: typing.Callable[[typing.List[str]], typing.List[str]], setter: typing.Callable[[typing.List[str]], None]) -> None: 
        """
        Add a string array property (SmallVector form).

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addSmallStringProperty(self, key: str, getter: typing.Callable[[typing.List[str]], str], setter: typing.Callable[[str], None]) -> None: 
        """
        Add a string property (SmallString form).

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addStringArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[str]], setter: typing.Callable[[typing.List[str]], None]) -> None: 
        """
        Add a string array property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addStringProperty(self, key: str, getter: typing.Callable[[], str], setter: typing.Callable[[str], None]) -> None: 
        """
        Add a string property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def addValueProperty(self, key: str, getter: typing.Callable[[], _pyntcore._ntcore.Value], setter: typing.Callable[[_pyntcore._ntcore.Value], None]) -> None: 
        """
        Add a NetworkTableValue property.

        :param key:    property name
        :param getter: getter function (returns current value)
        :param setter: setter function (sets new value)
        """
    def getEntry(self, key: str) -> _pyntcore._ntcore.NetworkTableEntry: 
        """
        Add a property without getters or setters.  This can be used to get
        entry handles for the function called by SetUpdateTable().

        :param key: property name

        :returns: Network table entry
        """
    def getTable(self) -> _pyntcore._ntcore.NetworkTable: 
        """
        Get the network table.

        :returns: The network table
        """
    def setActuator(self, value: bool) -> None: 
        """
        Set a flag indicating if this sendable should be treated as an actuator.
        By default this flag is false.

        :param value: true if actuator, false if not
        """
    def setSafeState(self, func: typing.Callable[[], None]) -> None: 
        """
        Set the function that should be called to set the Sendable into a safe
        state.  This is called when entering and exiting Live Window mode.

        :param func: function
        """
    def setSmartDashboardType(self, type: str) -> None: 
        """
        Set the string representation of the named data type that will be used
        by the smart dashboard for this sendable.

        :param type: data type
        """
    def setUpdateTable(self, func: typing.Callable[[], None]) -> None: 
        """
        Set the function that should be called to update the network table
        for things other than properties.  Note this function is not passed
        the network table object; instead it should use the entry handles
        returned by GetEntry().

        :param func: function
        """
    pass
class SendableBuilderImpl(SendableBuilder):
    def __init__(self) -> None: ...
    def addBooleanArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[int]], setter: typing.Callable[[typing.List[int]], None]) -> None: ...
    def addBooleanProperty(self, key: str, getter: typing.Callable[[], bool], setter: typing.Callable[[bool], None]) -> None: ...
    def addDoubleArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[float]], setter: typing.Callable[[typing.List[float]], None]) -> None: ...
    def addDoubleProperty(self, key: str, getter: typing.Callable[[], float], setter: typing.Callable[[float], None]) -> None: ...
    def addRawProperty(self, key: str, getter: typing.Callable[[], str], setter: typing.Callable[[str], None]) -> None: ...
    def addSmallBooleanArrayProperty(self, key: str, getter: typing.Callable[[typing.List[int]], typing.List[int]], setter: typing.Callable[[typing.List[int]], None]) -> None: ...
    def addSmallDoubleArrayProperty(self, key: str, getter: typing.Callable[[typing.List[float]], typing.List[float]], setter: typing.Callable[[typing.List[float]], None]) -> None: ...
    def addSmallRawProperty(self, key: str, getter: typing.Callable[[typing.List[str]], str], setter: typing.Callable[[str], None]) -> None: ...
    def addSmallStringArrayProperty(self, key: str, getter: typing.Callable[[typing.List[str]], typing.List[str]], setter: typing.Callable[[typing.List[str]], None]) -> None: ...
    def addSmallStringProperty(self, key: str, getter: typing.Callable[[typing.List[str]], str], setter: typing.Callable[[str], None]) -> None: ...
    def addStringArrayProperty(self, key: str, getter: typing.Callable[[], typing.List[str]], setter: typing.Callable[[typing.List[str]], None]) -> None: ...
    def addStringProperty(self, key: str, getter: typing.Callable[[], str], setter: typing.Callable[[str], None]) -> None: ...
    def addValueProperty(self, key: str, getter: typing.Callable[[], _pyntcore._ntcore.Value], setter: typing.Callable[[_pyntcore._ntcore.Value], None]) -> None: ...
    def clearProperties(self) -> None: 
        """
        Clear properties.
        """
    def getEntry(self, key: str) -> _pyntcore._ntcore.NetworkTableEntry: ...
    def getTable(self) -> _pyntcore._ntcore.NetworkTable: 
        """
        Get the network table.

        :returns: The network table
        """
    def hasTable(self) -> bool: 
        """
        Return whether this sendable has an associated table.

        :returns: True if it has a table, false if not.
        """
    def isActuator(self) -> bool: 
        """
        Return whether this sendable should be treated as an actuator.

        :returns: True if actuator, false if not.
        """
    def setActuator(self, value: bool) -> None: ...
    def setSafeState(self, func: typing.Callable[[], None]) -> None: ...
    def setSmartDashboardType(self, type: str) -> None: ...
    def setTable(self, table: _pyntcore._ntcore.NetworkTable) -> None: 
        """
        Set the network table.  Must be called prior to any Add* functions being
        called.

        :param table: Network table
        """
    def setUpdateTable(self, func: typing.Callable[[], None]) -> None: ...
    def startListeners(self) -> None: 
        """
        Hook setters for all properties.
        """
    def startLiveWindowMode(self) -> None: 
        """
        Start LiveWindow mode by hooking the setters for all properties.  Also
        calls the SafeState function if one was provided.
        """
    def stopListeners(self) -> None: 
        """
        Unhook setters for all properties.
        """
    def stopLiveWindowMode(self) -> None: 
        """
        Stop LiveWindow mode by unhooking the setters for all properties.  Also
        calls the SafeState function if one was provided.
        """
    def updateTable(self) -> None: 
        """
        Update the network table values by calling the getters for all properties.
        """
    pass
class SendableChooserBase(Sendable):
    """
    This class is a non-template base class for SendableChooser.

    It contains static, non-templated variables to avoid their duplication in the
    template class.
    """
    @property
    def _m_activeEntries(self) -> typing.List[_pyntcore._ntcore.NetworkTableEntry]:
        """
        :type: typing.List[_pyntcore._ntcore.NetworkTableEntry]
        """
    @property
    def _m_defaultChoice(self) -> str:
        """
        :type: str
        """
    @property
    def _m_haveSelected(self) -> bool:
        """
        :type: bool
        """
    @_m_haveSelected.setter
    def _m_haveSelected(self, arg0: bool) -> None:
        pass
    @property
    def _m_instance(self) -> int:
        """
        :type: int
        """
    @_m_instance.setter
    def _m_instance(self, arg0: int) -> None:
        pass
    @property
    def _m_selected(self) -> str:
        """
        :type: str
        """
    _kActive = 'active'
    _kDefault = 'default'
    _kInstance = '.instance'
    _kOptions = 'options'
    _kSelected = 'selected'
    pass
class SendableChooser(SendableChooserBase, Sendable):
    """
    The SendableChooser class is a useful tool for presenting a selection of
    options to the SmartDashboard.

    For instance, you may wish to be able to select between multiple autonomous
    modes. You can do this by putting every possible Command you want to run as
    an autonomous into a SendableChooser and then put it into the SmartDashboard
    to have a list of options appear on the laptop. Once autonomous starts,
    simply ask the SendableChooser what the selected value is.

    @tparam T The type of values to be stored
    @see SmartDashboard
    """
    def __init__(self) -> None: ...
    def addOption(self, name: str, object: object) -> None: 
        """
        Adds the given object to the list of options.

        On the SmartDashboard on the desktop, the object will appear as the given
        name.

        :param name:   the name of the option
        :param object: the option
        """
    def getSelected(self) -> object: 
        """
        Returns a copy of the selected option (a raw pointer U* if T =
        std::unique_ptr<U> or a std::weak_ptr<U> if T = std::shared_ptr<U>).

        If there is none selected, it will return the default. If there is none
        selected and no default, then it will return a value-initialized instance.
        For integer types, this is 0. For container types like std::string, this is
        an empty string.

        :returns: The option selected
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def setDefaultOption(self, name: str, object: object) -> None: 
        """
        Add the given object to the list of options and marks it as the default.

        Functionally, this is very close to AddOption() except that it will use
        this as the default option if none other is explicitly selected.

        :param name:   the name of the option
        :param object: the option
        """
    _kActive = 'active'
    _kDefault = 'default'
    _kInstance = '.instance'
    _kOptions = 'options'
    _kSelected = 'selected'
    pass
class SendableRegistry():
    """
    The SendableRegistry class is the public interface for registering sensors
    and actuators for use on dashboards and LiveWindow.
    """
    @typing.overload
    def add(self, sendable: Sendable, moduleType: str, channel: int) -> None: 
        """
        Adds an object to the registry.

        :param sendable: object to add
        :param name:     component name

        Adds an object to the registry.

        :param sendable:   object to add
        :param moduleType: A string that defines the module name in the label for
                           the value
        :param channel:    The channel number the device is plugged into

        Adds an object to the registry.

        :param sendable:     object to add
        :param moduleType:   A string that defines the module name in the label for
                             the value
        :param moduleNumber: The number of the particular module type
        :param channel:      The channel number the device is plugged into

        Adds an object to the registry.

        :param sendable:  object to add
        :param subsystem: subsystem name
        :param name:      component name
        """
    @typing.overload
    def add(self, sendable: Sendable, moduleType: str, moduleNumber: int, channel: int) -> None: ...
    @typing.overload
    def add(self, sendable: Sendable, name: str) -> None: ...
    @typing.overload
    def add(self, sendable: Sendable, subsystem: str, name: str) -> None: ...
    def addChild(self, parent: Sendable, child: Sendable) -> None: 
        """
        Adds a child object to an object.  Adds the child object to the registry
        if it's not already present.

        :param parent: parent object
        :param child:  child object
        """
    @typing.overload
    def addLW(self, sendable: Sendable, moduleType: str, channel: int) -> None: 
        """
        Adds an object to the registry and LiveWindow.

        :param sendable: object to add
        :param name:     component name

        Adds an object to the registry and LiveWindow.

        :param sendable:   object to add
        :param moduleType: A string that defines the module name in the label for
                           the value
        :param channel:    The channel number the device is plugged into

        Adds an object to the registry and LiveWindow.

        :param sendable:     object to add
        :param moduleType:   A string that defines the module name in the label for
                             the value
        :param moduleNumber: The number of the particular module type
        :param channel:      The channel number the device is plugged into

        Adds an object to the registry and LiveWindow.

        :param sendable:  object to add
        :param subsystem: subsystem name
        :param name:      component name
        """
    @typing.overload
    def addLW(self, sendable: Sendable, moduleType: str, moduleNumber: int, channel: int) -> None: ...
    @typing.overload
    def addLW(self, sendable: Sendable, name: str) -> None: ...
    @typing.overload
    def addLW(self, sendable: Sendable, subsystem: str, name: str) -> None: ...
    def contains(self, sendable: Sendable) -> bool: 
        """
        Determines if an object is in the registry.

        :param sendable: object to check

        :returns: True if in registry, false if not.
        """
    def disableLiveWindow(self, sendable: Sendable) -> None: 
        """
        Disables LiveWindow for an object.

        :param sendable: object
        """
    def enableLiveWindow(self, sendable: Sendable) -> None: 
        """
        Enables LiveWindow for an object.

        :param sendable: object
        """
    @staticmethod
    def getInstance() -> SendableRegistry: 
        """
        Gets an instance of the SendableRegistry class.

        This is a singleton to guarantee that there is only a single instance
        regardless of how many times GetInstance is called.
        """
    def getName(self, sendable: Sendable) -> str: 
        """
        Gets the name of an object.

        :param sendable: object

        :returns: Name (empty if object is not in registry)
        """
    def getSendable(self, uid: int) -> Sendable: 
        """
        Get sendable object for a given unique id.

        :param uid: unique id

        :returns: sendable object (may be null)
        """
    def getSubsystem(self, sendable: Sendable) -> str: 
        """
        Gets the subsystem name of an object.

        :param sendable: object

        :returns: Subsystem name (empty if object is not in registry)
        """
    def getUniqueId(self, sendable: Sendable) -> int: 
        """
        Get unique id for an object.  Since objects can move, use this instead
        of storing Sendable* directly if ownership is in question.

        :param sendable: object

        :returns: unique id
        """
    def publish(self, sendableUid: int, table: _pyntcore._ntcore.NetworkTable) -> None: 
        """
        Publishes an object in the registry to a network table.

        :param sendableUid: sendable unique id
        :param table:       network table
        """
    def remove(self, sendable: Sendable) -> bool: 
        """
        Removes an object from the registry.

        :param sendable: object to remove

        :returns: true if the object was removed; false if it was not present
        """
    @typing.overload
    def setName(self, sendable: Sendable, moduleType: str, channel: int) -> None: 
        """
        Sets the name of an object.

        :param sendable: object
        :param name:     name

        Sets the name of an object with a channel number.

        :param sendable:   object
        :param moduleType: A string that defines the module name in the label for
                           the value
        :param channel:    The channel number the device is plugged into

        Sets the name of an object with a module and channel number.

        :param sendable:     object
        :param moduleType:   A string that defines the module name in the label for
                             the value
        :param moduleNumber: The number of the particular module type
        :param channel:      The channel number the device is plugged into

        Sets both the subsystem name and device name of an object.

        :param sendable:  object
        :param subsystem: subsystem name
        :param name:      device name
        """
    @typing.overload
    def setName(self, sendable: Sendable, moduleType: str, moduleNumber: int, channel: int) -> None: ...
    @typing.overload
    def setName(self, sendable: Sendable, name: str) -> None: ...
    @typing.overload
    def setName(self, sendable: Sendable, subsystem: str, name: str) -> None: ...
    def setSubsystem(self, sendable: Sendable, subsystem: str) -> None: 
        """
        Sets the subsystem name of an object.

        :param sendable:  object
        :param subsystem: subsystem name
        """
    def update(self, sendableUid: int) -> None: 
        """
        Updates network table information from an object.

        :param sendableUid: sendable unique id
        """
    pass
class SensorUtil():
    """
    Stores most recent status information as well as containing utility functions
    for checking channels and error processing.
    """
    @staticmethod
    def checkAnalogInputChannel(channel: int) -> bool: 
        """
        Check that the analog input number is value.

        Verify that the analog input number is one of the legal channel numbers.
        Channel numbers are 0-based.

        :returns: Analog channel is valid
        """
    @staticmethod
    def checkAnalogOutputChannel(channel: int) -> bool: 
        """
        Check that the analog output number is valid.

        Verify that the analog output number is one of the legal channel numbers.
        Channel numbers are 0-based.

        :returns: Analog channel is valid
        """
    @staticmethod
    def checkDigitalChannel(channel: int) -> bool: 
        """
        Check that the digital channel number is valid.

        Verify that the channel number is one of the legal channel numbers. Channel
        numbers are 0-based.

        :returns: Digital channel is valid
        """
    @staticmethod
    def checkPDPChannel(channel: int) -> bool: 
        """
        Verify that the power distribution channel number is within limits.

        :returns: PDP channel is valid
        """
    @staticmethod
    def checkPDPModule(module: int) -> bool: 
        """
        Verify that the PDP module number is within limits. module numbers are
        0-based

        :returns: PDP module is valid
        """
    @staticmethod
    def checkPWMChannel(channel: int) -> bool: 
        """
        Check that the digital channel number is valid.

        Verify that the channel number is one of the legal channel numbers. Channel
        numbers are 0-based.

        :returns: PWM channel is valid
        """
    @staticmethod
    def checkRelayChannel(channel: int) -> bool: 
        """
        Check that the relay channel number is valid.

        Verify that the channel number is one of the legal channel numbers. Channel
        numbers are 0-based.

        :returns: Relay channel is valid
        """
    @staticmethod
    def checkSolenoidChannel(channel: int) -> bool: 
        """
        Verify that the solenoid channel number is within limits.

        :returns: Solenoid channel is valid
        """
    @staticmethod
    def checkSolenoidModule(moduleNumber: int) -> bool: 
        """
        Check that the solenoid module number is valid. module numbers are 0-based

        :returns: Solenoid module is valid and present
        """
    @staticmethod
    def getDefaultSolenoidModule() -> int: 
        """
        Get the number of the default solenoid module.

        :returns: The number of the default solenoid module.
        """
    kAnalogInputs = 1608263167
    kDigitalChannels = 1608656383
    kPDPChannels = 1608525311
    kPwmChannels = 1607869951
    kRelayChannels = 1608001023
    kSolenoidChannels = 1608132095
    kSolenoidModules = 1608394239
    pass
class SerialPort(ErrorBase):
    """
    Driver for the RS-232 serial port on the roboRIO.

    The current implementation uses the VISA formatted I/O mode.  This means that
    all traffic goes through the fomatted buffers.  This allows the intermingled
    use of Printf(), Scanf(), and the raw buffer accessors Read() and Write().

    More information can be found in the NI-VISA User Manual here:
    http://www.ni.com/pdf/manuals/370423a.pdf
    and the NI-VISA Programmer's Reference Manual here:
    http://www.ni.com/pdf/manuals/370132c.pdf
    """
    class FlowControl():
        """
        Members:

          kFlowControl_None

          kFlowControl_XonXoff

          kFlowControl_RtsCts

          kFlowControl_DtrDsr
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kFlowControl_None': <FlowControl.kFlowControl_None: 0>, 'kFlowControl_XonXoff': <FlowControl.kFlowControl_XonXoff: 1>, 'kFlowControl_RtsCts': <FlowControl.kFlowControl_RtsCts: 2>, 'kFlowControl_DtrDsr': <FlowControl.kFlowControl_DtrDsr: 4>}
        kFlowControl_DtrDsr: wpilib._wpilib.SerialPort.FlowControl # value = <FlowControl.kFlowControl_DtrDsr: 4>
        kFlowControl_None: wpilib._wpilib.SerialPort.FlowControl # value = <FlowControl.kFlowControl_None: 0>
        kFlowControl_RtsCts: wpilib._wpilib.SerialPort.FlowControl # value = <FlowControl.kFlowControl_RtsCts: 2>
        kFlowControl_XonXoff: wpilib._wpilib.SerialPort.FlowControl # value = <FlowControl.kFlowControl_XonXoff: 1>
        pass
    class Parity():
        """
        Members:

          kParity_None

          kParity_Odd

          kParity_Even

          kParity_Mark

          kParity_Space
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kParity_None': <Parity.kParity_None: 0>, 'kParity_Odd': <Parity.kParity_Odd: 1>, 'kParity_Even': <Parity.kParity_Even: 2>, 'kParity_Mark': <Parity.kParity_Mark: 3>, 'kParity_Space': <Parity.kParity_Space: 4>}
        kParity_Even: wpilib._wpilib.SerialPort.Parity # value = <Parity.kParity_Even: 2>
        kParity_Mark: wpilib._wpilib.SerialPort.Parity # value = <Parity.kParity_Mark: 3>
        kParity_None: wpilib._wpilib.SerialPort.Parity # value = <Parity.kParity_None: 0>
        kParity_Odd: wpilib._wpilib.SerialPort.Parity # value = <Parity.kParity_Odd: 1>
        kParity_Space: wpilib._wpilib.SerialPort.Parity # value = <Parity.kParity_Space: 4>
        pass
    class Port():
        """
        Members:

          kOnboard

          kMXP

          kUSB

          kUSB1

          kUSB2
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kOnboard': <Port.kOnboard: 0>, 'kMXP': <Port.kMXP: 1>, 'kUSB': <Port.kUSB: 2>, 'kUSB1': <Port.kUSB: 2>, 'kUSB2': <Port.kUSB2: 3>}
        kMXP: wpilib._wpilib.SerialPort.Port # value = <Port.kMXP: 1>
        kOnboard: wpilib._wpilib.SerialPort.Port # value = <Port.kOnboard: 0>
        kUSB: wpilib._wpilib.SerialPort.Port # value = <Port.kUSB: 2>
        kUSB1: wpilib._wpilib.SerialPort.Port # value = <Port.kUSB: 2>
        kUSB2: wpilib._wpilib.SerialPort.Port # value = <Port.kUSB2: 3>
        pass
    class StopBits():
        """
        Members:

          kStopBits_One

          kStopBits_OnePointFive

          kStopBits_Two
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kStopBits_One': <StopBits.kStopBits_One: 10>, 'kStopBits_OnePointFive': <StopBits.kStopBits_OnePointFive: 15>, 'kStopBits_Two': <StopBits.kStopBits_Two: 20>}
        kStopBits_One: wpilib._wpilib.SerialPort.StopBits # value = <StopBits.kStopBits_One: 10>
        kStopBits_OnePointFive: wpilib._wpilib.SerialPort.StopBits # value = <StopBits.kStopBits_OnePointFive: 15>
        kStopBits_Two: wpilib._wpilib.SerialPort.StopBits # value = <StopBits.kStopBits_Two: 20>
        pass
    class WriteBufferMode():
        """
        Members:

          kFlushOnAccess

          kFlushWhenFull
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kFlushOnAccess': <WriteBufferMode.kFlushOnAccess: 1>, 'kFlushWhenFull': <WriteBufferMode.kFlushWhenFull: 2>}
        kFlushOnAccess: wpilib._wpilib.SerialPort.WriteBufferMode # value = <WriteBufferMode.kFlushOnAccess: 1>
        kFlushWhenFull: wpilib._wpilib.SerialPort.WriteBufferMode # value = <WriteBufferMode.kFlushWhenFull: 2>
        pass
    @typing.overload
    def __init__(self, baudRate: int, port: SerialPort.Port = Port.kOnboard, dataBits: int = 8, parity: SerialPort.Parity = Parity.kParity_None, stopBits: SerialPort.StopBits = StopBits.kStopBits_One) -> None: 
        """
        Create an instance of a Serial Port class.

        :param baudRate: The baud rate to configure the serial port.
        :param port:     The physical port to use
        :param dataBits: The number of data bits per transfer.  Valid values are
                         between 5 and 8 bits.
        :param parity:   Select the type of parity checking to use.
        :param stopBits: The number of stop bits to use as defined by the enum
                         StopBits.

        Create an instance of a Serial Port class.

        Prefer to use the constructor that doesn't take a port name, but in some
        cases the automatic detection might not work correctly.

        :param baudRate: The baud rate to configure the serial port.
        :param port:     The physical port to use
        :param portName: The direct port name to use
        :param dataBits: The number of data bits per transfer.  Valid values are
                         between 5 and 8 bits.
        :param parity:   Select the type of parity checking to use.
        :param stopBits: The number of stop bits to use as defined by the enum
                         StopBits.
        """
    @typing.overload
    def __init__(self, baudRate: int, portName: str, port: SerialPort.Port = Port.kOnboard, dataBits: int = 8, parity: SerialPort.Parity = Parity.kParity_None, stopBits: SerialPort.StopBits = StopBits.kStopBits_One) -> None: ...
    def disableTermination(self) -> None: 
        """
        Disable termination behavior.
        """
    def enableTermination(self, terminator: str = '\n') -> None: 
        """
        Enable termination and specify the termination character.

        Termination is currently only implemented for receive.
        When the the terminator is received, the Read() or Scanf() will return
        fewer bytes than requested, stopping after the terminator.

        :param terminator: The character to use for termination.
        """
    def flush(self) -> None: 
        """
        Force the output buffer to be written to the port.

        This is used when SetWriteBufferMode() is set to kFlushWhenFull to force a
        flush before the buffer is full.
        """
    def getBytesReceived(self) -> int: 
        """
        Get the number of bytes currently available to read from the serial port.

        :returns: The number of bytes available to read
        """
    def read(self, buffer: buffer) -> int: 
        """
        Read raw bytes out of the buffer.

        :param buffer: Pointer to the buffer to store the bytes in.
        :param count:  The maximum number of bytes to read.

        :returns: The number of bytes actually read into the buffer.
        """
    def reset(self) -> None: 
        """
        Reset the serial port driver to a known state.

        Empty the transmit and receive buffers in the device and formatted I/O.
        """
    def setFlowControl(self, flowControl: SerialPort.FlowControl) -> None: 
        """
        Set the type of flow control to enable on this port.

        By default, flow control is disabled.
        """
    def setReadBufferSize(self, size: int) -> None: 
        """
        Specify the size of the input buffer.

        Specify the amount of data that can be stored before data
        from the device is returned to Read or Scanf.  If you want
        data that is received to be returned immediately, set this to 1.

        It the buffer is not filled before the read timeout expires, all
        data that has been received so far will be returned.

        :param size: The read buffer size.
        """
    def setTimeout(self, timeout: float) -> None: 
        """
        Configure the timeout of the serial port.

        This defines the timeout for transactions with the hardware.
        It will affect reads and very large writes.

        :param timeout: The number of seconds to to wait for I/O.
        """
    def setWriteBufferMode(self, mode: SerialPort.WriteBufferMode) -> None: 
        """
        Specify the flushing behavior of the output buffer.

        When set to kFlushOnAccess, data is synchronously written to the serial
        port after each call to either Printf() or Write().

        When set to kFlushWhenFull, data will only be written to the serial port
        when the buffer is full or when Flush() is called.

        :param mode: The write buffer mode.
        """
    def setWriteBufferSize(self, size: int) -> None: 
        """
        Specify the size of the output buffer.

        Specify the amount of data that can be stored before being
        transmitted to the device.

        :param size: The write buffer size.
        """
    def write(self, buffer: buffer) -> int: 
        """
        Write raw bytes to the buffer.

        :param buffer: Pointer to the buffer to read the bytes from.
        :param count:  The maximum number of bytes to write.

        :returns: The number of bytes actually written into the port.
        """
    pass
class Servo(PWM, MotorSafety, ErrorBase, Sendable):
    """
    Standard hobby style servo.

    The range parameters default to the appropriate values for the Hitec HS-322HD
    servo provided in the FIRST Kit of Parts in 2008.
    """
    def __init__(self, channel: int) -> None: 
        """
        :param channel: The PWM channel to which the servo is attached. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    def get(self) -> float: 
        """
        Get the servo position.

        Servo values range from 0.0 to 1.0 corresponding to the range of full left
        to full right.

        :returns: Position from 0.0 to 1.0.
        """
    def getAngle(self) -> float: 
        """
        Get the servo angle.

        Assume that the servo angle is linear with respect to the PWM value (big
        assumption, need to test).

        :returns: The angle in degrees to which the servo is set.
        """
    def getMaxAngle(self) -> float: 
        """
        Get the maximum angle of the servo.

        :returns: The maximum angle of the servo in degrees.
        """
    def getMinAngle(self) -> float: 
        """
        Get the minimum angle of the servo.

        :returns: The minimum angle of the servo in degrees.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def set(self, value: float) -> None: 
        """
        Set the servo position.

        Servo values range from 0.0 to 1.0 corresponding to the range of full left
        to full right.

        :param value: Position from 0.0 to 1.0.
        """
    def setAngle(self, angle: float) -> None: 
        """
        Set the servo angle.

        Assume that the servo angle is linear with respect to the PWM value (big
        assumption, need to test).

        Servo angles that are out of the supported range of the servo simply
        "saturate" in that direction. In other words, if the servo has a range of
        (X degrees to Y degrees) than angles of less than X result in an angle of
        X being set and angles of more than Y degrees result in an angle of Y being
        set.

        :param degrees: The angle in degrees to set the servo.
        """
    def setOffline(self) -> None: 
        """
        Set the servo to offline.

        Set the servo raw value to 0 (undriven)
        """
    pass
class SlewRateLimiter():
    """
    A class that limits the rate of change of an input value.  Useful for
    implementing voltage, setpoint, and/or output ramps.  A slew-rate limit
    is most appropriate when the quantity being controlled is a velocity or
    a voltage; when controlling a position, consider using a TrapezoidProfile
    instead.

    @see TrapezoidProfile
    """
    def __init__(self, rateLimit: units_per_second, initialValue: float = 0.0) -> None: 
        """
        Creates a new SlewRateLimiter with the given rate limit and initial value.

        :param rateLimit:    The rate-of-change limit.
        :param initialValue: The initial value of the input.
        """
    def calculate(self, input: float) -> float: 
        """
        Filters the input to limit its slew rate.

        :param input: The input value whose slew rate is to be limited.

        :returns: The filtered value, which will not change faster than the slew
                  rate.
        """
    def reset(self, value: float) -> None: 
        """
        Resets the slew rate limiter to the specified value; ignores the rate limit
        when doing so.

        :param value: The value to reset to.
        """
    pass
class SmartDashboard():
    @staticmethod
    def clearFlags(key: str, flags: int) -> None: 
        """
        Clears flags on the specified key in this table. The key can
        not be null.

        :param key:   the key name
        :param flags: the flags to clear (bitmask)
        """
    @staticmethod
    def clearPersistent(key: str) -> None: 
        """
        Stop making a key's value persistent through program restarts.
        The key cannot be null.

        :param key: the key name
        """
    @staticmethod
    def containsKey(key: str) -> bool: 
        """
        Determines whether the given key is in this table.

        :param key: the key to search for

        :returns: true if the table as a value assigned to the given key
        """
    @staticmethod
    def delete(key: str) -> None: 
        """
        Deletes the specified key in this table.

        :param key: the key name
        """
    @staticmethod
    def getBoolean(keyName: str, defaultValue: object) -> object: 
        """
        Returns the value at the specified key.

        If the key is not found, returns the default value.

        :param keyName: the key

        :returns: the value
        """
    @staticmethod
    def getBooleanArray(key: str, defaultValue: object) -> object: 
        """
        Returns the boolean array the key maps to.

        If the key does not exist or is of different type, it will return the
        default value.

        :param key:          The key to look up.
        :param defaultValue: The value to be returned if no value is found.

        :returns: the value associated with the given key or the given default value
                  if there is no value associated with the key
                  
                  @note This makes a copy of the array. If the overhead of this is a concern,
                  use GetValue() instead.
                  
                  @note The returned array is std::vector<int> instead of std::vector<bool>
                  because std::vector<bool> is special-cased in C++. 0 is false, any
                  non-zero value is true.
        """
    @staticmethod
    def getData(keyName: str) -> Sendable: 
        """
        Returns the value at the specified key.

        :param keyName: the key

        :returns: the value
        """
    @staticmethod
    def getEntry(key: str) -> _pyntcore._ntcore.NetworkTableEntry: 
        """
        Returns an NT Entry mapping to the specified key

        This is useful if an entry is used often, or is read and then modified.

        :param key: the key

        :returns: the entry for the key
        """
    @staticmethod
    def getFlags(key: str) -> int: 
        """
        Returns the flags for the specified key.

        :param key: the key name

        :returns: the flags, or 0 if the key is not defined
        """
    @staticmethod
    def getKeys(types: int = 0) -> typing.List[str]: 
        """
        :param types: bitmask of types; 0 is treated as a "don't care".

        :returns: keys currently in the table
        """
    @staticmethod
    def getNumber(keyName: str, defaultValue: object) -> object: 
        """
        Returns the value at the specified key.

        If the key is not found, returns the default value.

        :param keyName: the key

        :returns: the value
        """
    @staticmethod
    def getNumberArray(key: str, defaultValue: object) -> object: 
        """
        Returns the number array the key maps to.

        If the key does not exist or is of different type, it will return the
        default value.

        :param key:          The key to look up.
        :param defaultValue: The value to be returned if no value is found.

        :returns: the value associated with the given key or the given default value
                  if there is no value associated with the key
                  
                  @note This makes a copy of the array. If the overhead of this is a concern,
                  use GetValue() instead.
        """
    @staticmethod
    def getRaw(key: str, defaultValue: object) -> object: 
        """
        Returns the raw value (byte array) the key maps to.

        If the key does not exist or is of different type, it will return the
        default value.

        :param key:          The key to look up.
        :param defaultValue: The value to be returned if no value is found.

        :returns: the value associated with the given key or the given default value
                  if there is no value associated with the key
                  
                  @note This makes a copy of the raw contents. If the overhead of this is a
                  concern, use GetValue() instead.
        """
    @staticmethod
    def getString(keyName: str, defaultValue: object) -> object: 
        """
        Returns the value at the specified key.

        If the key is not found, returns the default value.

        :param keyName: the key

        :returns: the value
        """
    @staticmethod
    def getStringArray(key: str, defaultValue: object) -> object: 
        """
        Returns the string array the key maps to.

        If the key does not exist or is of different type, it will return the
        default value.

        :param key:          The key to look up.
        :param defaultValue: The value to be returned if no value is found.

        :returns: the value associated with the given key or the given default value
                  if there is no value associated with the key
                  
                  @note This makes a copy of the array. If the overhead of this is a concern,
                  use GetValue() instead.
        """
    @staticmethod
    def getValue(keyName: str) -> _pyntcore._ntcore.Value: 
        """
        Retrieves the complex value (such as an array) in this table into the
        complex data object.

        :param keyName: the key
        :param value:   the object to retrieve the value into
        """
    @staticmethod
    def init() -> None: ...
    @staticmethod
    def isPersistent(key: str) -> bool: 
        """
        Returns whether the value is persistent through program restarts.
        The key cannot be null.

        :param key: the key name
        """
    @staticmethod
    def postListenerTask(task: typing.Callable[[], None]) -> None: 
        """
        Posts a task from a listener to the ListenerExecutor, so that it can be run
        synchronously from the main loop on the next call to {@link
        SmartDashboard#updateValues()}.

        :param task: The task to run synchronously from the main thread.
        """
    @staticmethod
    def putBoolean(keyName: str, value: bool) -> bool: 
        """
        Maps the specified key to the specified value in this table.

        The value can be retrieved by calling the get method with a key that is
        equal to the original key.

        :param keyName: the key
        :param value:   the value

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putBooleanArray(key: str, value: typing.List[int]) -> bool: 
        """
        Put a boolean array in the table.

        :param key:   the key to be assigned to
        :param value: the value that will be assigned

        :returns: False if the table key already exists with a different type
                  
                  @note The array must be of int's rather than of bool's because
                  std::vector<bool> is special-cased in C++. 0 is false, any
                  non-zero value is true.
        """
    @staticmethod
    @typing.overload
    def putData(key: str, data: Sendable) -> None: 
        """
        Maps the specified key to the specified value in this table.

        The value can be retrieved by calling the get method with a key that is
        equal to the original key.

        In order for the value to appear in the dashboard, it must be registered
        with SendableRegistry.  WPILib components do this automatically.

        :param keyName: the key
        :param value:   the value

        Maps the specified key (where the key is the name of the Sendable)
        to the specified value in this table.

        The value can be retrieved by calling the get method with a key that is
        equal to the original key.

        In order for the value to appear in the dashboard, it must be registered
        with SendableRegistry.  WPILib components do this automatically.

        :param value: the value
        """
    @staticmethod
    @typing.overload
    def putData(value: Sendable) -> None: ...
    @staticmethod
    def putNumber(keyName: str, value: float) -> bool: 
        """
        Maps the specified key to the specified value in this table.

        The value can be retrieved by calling the get method with a key that is
        equal to the original key.

        :param keyName: the key
        :param value:   the value

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putNumberArray(key: str, value: typing.List[float]) -> bool: 
        """
        Put a number array in the table.

        :param key:   The key to be assigned to.
        :param value: The value that will be assigned.

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putRaw(key: str, value: str) -> bool: 
        """
        Put a raw value (byte array) in the table.

        :param key:   The key to be assigned to.
        :param value: The value that will be assigned.

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putString(keyName: str, value: str) -> bool: 
        """
        Maps the specified key to the specified value in this table.

        The value can be retrieved by calling the get method with a key that is
        equal to the original key.

        :param keyName: the key
        :param value:   the value

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putStringArray(key: str, value: typing.List[str]) -> bool: 
        """
        Put a string array in the table.

        :param key:   The key to be assigned to.
        :param value: The value that will be assigned.

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def putValue(keyName: str, value: _pyntcore._ntcore.Value) -> bool: 
        """
        Maps the specified key to the specified complex value (such as an array) in
        this table.

        The value can be retrieved by calling the RetrieveValue method with a key
        that is equal to the original key.

        :param keyName: the key
        :param value:   the value

        :returns: False if the table key already exists with a different type
        """
    @staticmethod
    def setDefaultBoolean(key: str, defaultValue: bool) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          the key
        :param defaultValue: the default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultBooleanArray(key: str, defaultValue: typing.List[int]) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          the key
        :param defaultValue: the default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultNumber(key: str, defaultValue: float) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          The key.
        :param defaultValue: The default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultNumberArray(key: str, defaultValue: typing.List[float]) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          The key.
        :param defaultValue: The default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultRaw(key: str, defaultValue: str) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          The key.
        :param defaultValue: The default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultString(key: str, defaultValue: str) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          the key
        :param defaultValue: the default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultStringArray(key: str, defaultValue: typing.List[str]) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          The key.
        :param defaultValue: The default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setDefaultValue(key: str, defaultValue: _pyntcore._ntcore.Value) -> bool: 
        """
        Gets the current value in the table, setting it if it does not exist.

        :param key:          the key
        :param defaultValue: The default value to set if key doesn't exist.

        :returns: False if the table key exists with a different type
        """
    @staticmethod
    def setFlags(key: str, flags: int) -> None: 
        """
        Sets flags on the specified key in this table. The key can
        not be null.

        :param key:   the key name
        :param flags: the flags to set (bitmask)
        """
    @staticmethod
    def setPersistent(key: str) -> None: 
        """
        Makes a key's value persistent through program restarts.

        :param key: the key to make persistent
        """
    @staticmethod
    def updateValues() -> None: 
        """
        Puts all sendable data to the dashboard.
        """
    pass
class Solenoid(SolenoidBase, ErrorBase, Sendable):
    """
    Solenoid class for running high voltage Digital Output (PCM).

    The Solenoid class is typically used for pneumatics solenoids, but could be
    used for any device within the current spec of the PCM.
    """
    @typing.overload
    def __init__(self, channel: int) -> None: 
        """
        Constructor using the default PCM ID (0).

        :param channel: The channel on the PCM to control (0..7).

        Constructor.

        :param moduleNumber: The CAN ID of the PCM the solenoid is attached to
        :param channel:      The channel on the PCM to control (0..7).
        """
    @typing.overload
    def __init__(self, moduleNumber: int, channel: int) -> None: ...
    def get(self) -> bool: 
        """
        Read the current value of the solenoid.

        :returns: The current value of the solenoid.
        """
    def getChannel(self) -> int: 
        """
        Get the channel this solenoid is connected to.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isBlackListed(self) -> bool: 
        """
        Check if solenoid is blacklisted.

        If a solenoid is shorted, it is added to the blacklist and
        disabled until power cycle, or until faults are cleared.

        @see ClearAllPCMStickyFaults()

        :returns: If solenoid is disabled due to short.
        """
    def set(self, on: bool) -> None: 
        """
        Set the value of a solenoid.

        :param on: Turn the solenoid output off or on.
        """
    def setPulseDuration(self, durationSeconds: float) -> None: 
        """
        Set the pulse duration in the PCM. This is used in conjunction with
        the startPulse method to allow the PCM to control the timing of a pulse.
        The timing can be controlled in 0.01 second increments.

        @see startPulse()

        :param durationSeconds: The duration of the pulse, from 0.01 to 2.55
                                seconds.
        """
    def startPulse(self) -> None: 
        """
        Trigger the PCM to generate a pulse of the duration set in
        setPulseDuration.

        @see setPulseDuration()
        """
    def toggle(self) -> None: 
        """
        Toggle the value of the solenoid.

        If the solenoid is set to on, it'll be turned off. If the solenoid is set
        to off, it'll be turned on.
        """
    pass
class DoubleSolenoid(SolenoidBase, ErrorBase, Sendable):
    """
    DoubleSolenoid class for running 2 channels of high voltage Digital Output
    (PCM).

    The DoubleSolenoid class is typically used for pneumatics solenoids that
    have two positions controlled by two separate channels.
    """
    class Value():
        """
        Members:

          kOff

          kForward

          kReverse
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kOff': <Value.kOff: 0>, 'kForward': <Value.kForward: 1>, 'kReverse': <Value.kReverse: 2>}
        kForward: wpilib._wpilib.DoubleSolenoid.Value # value = <Value.kForward: 1>
        kOff: wpilib._wpilib.DoubleSolenoid.Value # value = <Value.kOff: 0>
        kReverse: wpilib._wpilib.DoubleSolenoid.Value # value = <Value.kReverse: 2>
        pass
    @typing.overload
    def __init__(self, forwardChannel: int, reverseChannel: int) -> None: 
        """
        Constructor.

        Uses the default PCM ID of 0.

        :param forwardChannel: The forward channel number on the PCM (0..7).
        :param reverseChannel: The reverse channel number on the PCM (0..7).

        Constructor.

        :param moduleNumber:   The CAN ID of the PCM.
        :param forwardChannel: The forward channel on the PCM to control (0..7).
        :param reverseChannel: The reverse channel on the PCM to control (0..7).
        """
    @typing.overload
    def __init__(self, moduleNumber: int, forwardChannel: int, reverseChannel: int) -> None: ...
    def get(self) -> DoubleSolenoid.Value: 
        """
        Read the current value of the solenoid.

        :returns: The current value of the solenoid.
        """
    def getFwdChannel(self) -> int: 
        """
        Get the forward channel.

        :returns: the forward channel.
        """
    def getRevChannel(self) -> int: 
        """
        Get the reverse channel.

        :returns: the reverse channel.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isFwdSolenoidBlackListed(self) -> bool: 
        """
        Check if the forward solenoid is blacklisted.

        If a solenoid is shorted, it is added to the blacklist and disabled until
        power cycle, or until faults are cleared.

        @see ClearAllPCMStickyFaults()

        :returns: If solenoid is disabled due to short.
        """
    def isRevSolenoidBlackListed(self) -> bool: 
        """
        Check if the reverse solenoid is blacklisted.

        If a solenoid is shorted, it is added to the blacklist and disabled until
        power cycle, or until faults are cleared.

        @see ClearAllPCMStickyFaults()

        :returns: If solenoid is disabled due to short.
        """
    def set(self, value: DoubleSolenoid.Value) -> None: 
        """
        Set the value of a solenoid.

        :param value: The value to set (Off, Forward or Reverse)
        """
    def toggle(self) -> None: 
        """
        Toggle the value of the solenoid.

        If the solenoid is set to forward, it'll be set to reverse. If the solenoid
        is set to reverse, it'll be set to forward. If the solenoid is set to off,
        nothing happens.
        """
    pass
class Spark(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    REV Robotics SPARK Speed Controller.

    Note that the SPARK uses the following bounds for PWM values. These values
    should work reasonably well for most controllers, but if users experience
    issues such as asymmetric behavior around the deadband or inability to
    saturate the controller in either direction, calibration is recommended.
    The calibration procedure can be found in the SPARK User Manual available
    from REV Robotics.

    - 2.003ms = full "forward"
    - 1.550ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.460ms = the "low end" of the deadband range
    - 0.999ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a SPARK.

        :param channel: The PWM channel that the SPARK is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class SpeedControllerGroup(Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    def __init__(self, *args) -> None: ...
    def disable(self) -> None: ...
    def get(self) -> float: ...
    def getInverted(self) -> bool: ...
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def pidWrite(self, output: float) -> None: ...
    def set(self, speed: float) -> None: ...
    def setInverted(self, isInverted: bool) -> None: ...
    def stopMotor(self) -> None: ...
    pass
class Talon(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Cross the Road Electronics (CTRE) Talon and Talon SR Speed Controller.

    Note that the Talon uses the following bounds for PWM values. These values
    should work reasonably well for most controllers, but if users experience
    issues such as asymmetric behavior around the deadband or inability to
    saturate the controller in either direction, calibration is recommended.
    The calibration procedure can be found in the Talon User Manual available
    from CTRE.

    - 2.037ms = full "forward"
    - 1.539ms = the "high end" of the deadband range
    - 1.513ms = center of the deadband range (off)
    - 1.487ms = the "low end" of the deadband range
    - 0.989ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a Talon (original or Talon SR).

        :param channel: The PWM channel number that the Talon is attached to. 0-9
                        are on-board, 10-19 are on the MXP port
        """
    pass
class TimedRobot(IterativeRobotBase, RobotBase):
    """
    TimedRobot implements the IterativeRobotBase robot program framework.

    The TimedRobot class is intended to be subclassed by a user creating a
    robot program.

    Periodic() functions from the base class are called on an interval by a
    Notifier instance.
    """
    def __init__(self, period: seconds = 0.02) -> None: 
        """
        Constructor for TimedRobot.

        :param period: Period.
        """
    def addPeriodic(self, callback: typing.Callable[[], None], period: seconds, offset: seconds = 0.0) -> None: 
        """
        Add a callback to run at a specific period with a starting time offset.

        This is scheduled on TimedRobot's Notifier, so TimedRobot and the callback
        run synchronously. Interactions between them are thread-safe.

        :param callback: The callback to run.
        :param period:   The period at which to run the callback.
        :param offset:   The offset from the common starting time. This is useful
                         for scheduling a callback in a different timeslot relative
                         to TimedRobot.
        """
    def endCompetition(self) -> None: 
        """
        Ends the main loop in StartCompetition().
        """
    def getPeriod(self) -> seconds: 
        """
        Get the time period between calls to Periodic() functions.
        """
    def startCompetition(self) -> None: 
        """
        Provide an alternate "main loop" via StartCompetition().
        """
    kDefaultPeriod = 0.02
    pass
class Timer():
    """
    A wrapper for the frc::Timer class that returns unit-typed values.
    """
    def __init__(self) -> None: 
        """
        Create a new timer object.

        Create a new timer object and reset the time to zero. The timer is
        initially not running and must be started.
        """
    def advanceIfElapsed(self, period: seconds) -> bool: 
        """
        Check if the period specified has passed and if it has, advance the start
        time by that period. This is useful to decide if it's time to do periodic
        work without drifting later by the time it took to get around to checking.

        :param period: The period to check for.

        :returns: True if the period has passed.
        """
    def get(self) -> seconds: 
        """
        Get the current time from the timer. If the clock is running it is derived
        from the current system clock the start time stored in the timer class. If
        the clock is not running, then return the time when it was last stopped.

        :returns: Current time value for this timer in seconds
        """
    @staticmethod
    def getFPGATimestamp() -> seconds: 
        """
        Return the FPGA system clock time in seconds.

        Return the time from the FPGA hardware clock in seconds since the FPGA
        started. Rolls over after 71 minutes.

        :returns: Robot running time in seconds.
        """
    @staticmethod
    def getMatchTime() -> seconds: 
        """
        Return the approximate match time.

        The FMS does not send an official match time to the robots, but does send
        an approximate match time. The value will count down the time remaining in
        the current period (auto or teleop).

        Warning: This is not an official time (so it cannot be used to dispute ref
        calls or guarantee that a function will trigger before the match ends).

        The Practice Match function of the DS approximates the behavior seen on the
        field.

        :returns: Time remaining in current match period (auto or teleop)
        """
    def hasElapsed(self, period: seconds) -> bool: 
        """
        Check if the period specified has passed.

        :param seconds: The period to check.

        :returns: True if the period has passed.
        """
    def hasPeriodPassed(self, period: seconds) -> bool: 
        """
        Check if the period specified has passed and if it has, advance the start
        time by that period. This is useful to decide if it's time to do periodic
        work without drifting later by the time it took to get around to checking.

        :param period: The period to check for.

        :returns: True if the period has passed.
        """
    def reset(self) -> None: 
        """
        Reset the timer by setting the time to 0.

        Make the timer startTime the current time so new requests will be relative
        to now.
        """
    def start(self) -> None: 
        """
        Start the timer running.

        Just set the running flag to true indicating that all time requests should
        be relative to the system clock. Note that this method is a no-op if the
        timer is already running.
        """
    def stop(self) -> None: 
        """
        Stop the timer.

        This computes the time as of now and clears the running flag, causing all
        subsequent time requests to be read from the accumulated time rather than
        looking at the system clock.
        """
    pass
class Tracer():
    """
    A class for keeping track of how much time it takes for different parts of
    code to execute. This is done with epochs, that are added to calls to
    AddEpoch() and can be printed with a call to PrintEpochs().

    Epochs are a way to partition the time elapsed so that when overruns occur,
    one can determine which parts of an operation consumed the most time.
    """
    def __init__(self) -> None: 
        """
        Constructs a Tracer instance.
        """
    def addEpoch(self, epochName: str) -> None: 
        """
        Adds time since last epoch to the list printed by PrintEpochs().

        Epochs are a way to partition the time elapsed so that when overruns occur,
        one can determine which parts of an operation consumed the most time.

        :param epochName: The name to associate with the epoch.
        """
    def clearEpochs(self) -> None: 
        """
        Clears all epochs.
        """
    def getEpochs(self) -> str: 
        """
        Retreives list of epochs added so far as a string

        .. versionadded:: 2021.1.2

        .. note:: This function only exists in RobotPy
        """
    def printEpochs(self) -> None: 
        """
        Prints list of epochs added so far and their times to the DriverStation.
        """
    def resetTimer(self) -> None: 
        """
        Restarts the epoch timer.
        """
    pass
class Ultrasonic(ErrorBase, Sendable, wpilib.interfaces._interfaces.PIDSource):
    """
    Ultrasonic rangefinder class.

    The Ultrasonic rangefinder measures absolute distance based on the round-trip
    time of a ping generated by the controller. These sensors use two
    transducers, a speaker and a microphone both tuned to the ultrasonic range. A
    common ultrasonic sensor, the Daventech SRF04 requires a short pulse to be
    generated on a digital channel. This causes the chirp to be emitted. A second
    line becomes high as the ping is transmitted and goes low when the echo is
    received. The time that the line is high determines the round trip distance
    (time of flight).
    """
    class DistanceUnit():
        """
        Members:

          kInches

          kMilliMeters
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kInches': <DistanceUnit.kInches: 0>, 'kMilliMeters': <DistanceUnit.kMilliMeters: 1>}
        kInches: wpilib._wpilib.Ultrasonic.DistanceUnit # value = <DistanceUnit.kInches: 0>
        kMilliMeters: wpilib._wpilib.Ultrasonic.DistanceUnit # value = <DistanceUnit.kMilliMeters: 1>
        pass
    @typing.overload
    def __init__(self, pingChannel: DigitalOutput, echoChannel: DigitalInput, units: Ultrasonic.DistanceUnit = DistanceUnit.kInches) -> None: 
        """
        Create an instance of the Ultrasonic Sensor.

        This is designed to support the Daventech SRF04 and Vex ultrasonic sensors.

        :param pingChannel: The digital output channel that sends the pulse to
                            initiate the sensor sending the ping.
        :param echoChannel: The digital input channel that receives the echo. The
                            length of time that the echo is high represents the
                            round trip time of the ping, and the distance.
        :param units:       The units returned in either kInches or kMilliMeters

        Create an instance of an Ultrasonic Sensor from a DigitalInput for the echo
        channel and a DigitalOutput for the ping channel.

        :param pingChannel: The digital output object that starts the sensor doing a
                            ping. Requires a 10uS pulse to start.
        :param echoChannel: The digital input object that times the return pulse to
                            determine the range.
        :param units:       The units returned in either kInches or kMilliMeters
        """
    @typing.overload
    def __init__(self, pingChannel: int, echoChannel: int, units: Ultrasonic.DistanceUnit = DistanceUnit.kInches) -> None: ...
    def getDistanceUnits(self) -> Ultrasonic.DistanceUnit: 
        """
        Get the current DistanceUnit that is used for the PIDSource base object.

        :returns: The type of DistanceUnit that is being used.
        """
    def getRangeInches(self) -> float: 
        """
        Get the range in inches from the ultrasonic sensor.

        :returns: Range in inches of the target returned from the ultrasonic sensor.
                  If there is no valid value yet, i.e. at least one measurement
                  hasn't completed, then return 0.
        """
    def getRangeMM(self) -> float: 
        """
        Get the range in millimeters from the ultrasonic sensor.

        :returns: Range in millimeters of the target returned by the ultrasonic
                  sensor. If there is no valid value yet, i.e. at least one
                  measurement hasn't completed, then return 0.
        """
    def initSendable(self, builder: SendableBuilder) -> None: ...
    def isEnabled(self) -> bool: ...
    def isRangeValid(self) -> bool: 
        """
        Check if there is a valid range measurement.

        The ranges are accumulated in a counter that will increment on each edge of
        the echo (return) signal. If the count is not at least 2, then the range
        has not yet been measured, and is invalid.
        """
    def pidGet(self) -> float: 
        """
        Get the range in the current DistanceUnit for the PIDSource base object.

        :returns: The range in DistanceUnit
        """
    def ping(self) -> None: 
        """
        Single ping to ultrasonic sensor.

        Send out a single ping to the ultrasonic sensor. This only works if
        automatic (round robin) mode is disabled. A single ping is sent out, and
        the counter should count the semi-period when it comes in. The counter is
        reset to make the current value invalid.
        """
    @staticmethod
    def setAutomaticMode(enabling: bool) -> None: 
        """
        Turn Automatic mode on/off.

        When in Automatic mode, all sensors will fire in round robin, waiting a set
        time between each sensor.

        :param enabling: Set to true if round robin scheduling should start for all
                         the ultrasonic sensors. This scheduling method assures that
                         the sensors are non-interfering because no two sensors fire
                         at the same time. If another scheduling algorithm is
                         preferred, it can be implemented by pinging the sensors
                         manually and waiting for the results to come back.
        """
    def setDistanceUnits(self, units: Ultrasonic.DistanceUnit) -> None: 
        """
        Set the current DistanceUnit that should be used for the PIDSource base
        object.

        :param units: The DistanceUnit that should be used.
        """
    def setEnabled(self, enable: bool) -> None: ...
    def setPIDSourceType(self, pidSource: wpilib.interfaces._interfaces.PIDSourceType) -> None: ...
    pass
class Victor(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Vex Robotics Victor 888 Speed Controller.

    The Vex Robotics Victor 884 Speed Controller can also be used with this
    class but may need to be calibrated per the Victor 884 user manual.

    Note that the Victor uses the following bounds for PWM values.  These
    values were determined empirically and optimized for the Victor 888. These
    values should work reasonably well for Victor 884 controllers as well but
    if users experience issues such as asymmetric behavior around the deadband
    or inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the Victor 884 User
    Manual available from Vex.

    - 2.027ms = full "forward"
    - 1.525ms = the "high end" of the deadband range
    - 1.507ms = center of the deadband range (off)
    - 1.490ms = the "low end" of the deadband range
    - 1.026ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a Victor.

        :param channel: The PWM channel number that the Victor is attached to. 0-9
                        are on-board, 10-19 are on the MXP port
        """
    pass
class VictorSP(PWMSpeedController, PWM, MotorSafety, ErrorBase, Sendable, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput):
    """
    Vex Robotics Victor SP Speed Controller.

    Note that the Victor SP uses the following bounds for PWM values. These
    values should work reasonably well for most controllers, but if users
    experience issues such as asymmetric behavior around the deadband or
    inability to saturate the controller in either direction, calibration is
    recommended. The calibration procedure can be found in the Victor SP User
    Manual available from Vex.

    - 2.004ms = full "forward"
    - 1.520ms = the "high end" of the deadband range
    - 1.500ms = center of the deadband range (off)
    - 1.480ms = the "low end" of the deadband range
    - 0.997ms = full "reverse"
    """
    def __init__(self, channel: int) -> None: 
        """
        Constructor for a Victor SP.

        :param channel: The PWM channel that the VictorSP is attached to. 0-9 are
                        on-board, 10-19 are on the MXP port
        """
    pass
class Watchdog():
    """
    A class that's a wrapper around a watchdog timer.

    When the timer expires, a message is printed to the console and an optional
    user-provided callback is invoked.

    The watchdog is initialized disabled, so the user needs to call Enable()
    before use.
    """
    def __init__(self, timeout: seconds, callback: typing.Callable[[], None]) -> None: 
        """
        Watchdog constructor.

        :param timeout:  The watchdog's timeout in seconds with microsecond
                         resolution.
        :param callback: This function is called when the timeout expires.
        """
    def addEpoch(self, epochName: str) -> None: 
        """
        Adds time since last epoch to the list printed by PrintEpochs().

        Epochs are a way to partition the time elapsed so that when overruns occur,
        one can determine which parts of an operation consumed the most time.

        :param epochName: The name to associate with the epoch.
        """
    def disable(self) -> None: 
        """
        Disables the watchdog timer.
        """
    def enable(self) -> None: 
        """
        Enables the watchdog timer.
        """
    def getTime(self) -> float: 
        """
        Returns the time in seconds since the watchdog was last fed.
        """
    def getTimeout(self) -> float: 
        """
        Returns the watchdog's timeout in seconds.
        """
    def isExpired(self) -> bool: 
        """
        Returns true if the watchdog timer has expired.
        """
    def printEpochs(self) -> None: 
        """
        Prints list of epochs added so far and their times.
        """
    def reset(self) -> None: 
        """
        Resets the watchdog timer.

        This also enables the timer if it was previously disabled.
        """
    def setTimeout(self, timeout: seconds) -> None: 
        """
        Sets the watchdog's timeout.

        :param timeout: The watchdog's timeout in seconds with microsecond
                        resolution.
        """
    def suppressTimeoutMessage(self, suppress: bool) -> None: 
        """
        Enable or disable suppression of the generic timeout message.

        This may be desirable if the user-provided callback already prints a more
        specific message.

        :param suppress: Whether to suppress generic timeout message.
        """
    pass
class XboxController(wpilib.interfaces._interfaces.GenericHID):
    """
    Handle input from Xbox 360 or Xbox One controllers connected to the Driver
    Station.

    This class handles Xbox input that comes from the Driver Station. Each time a
    value is requested the most recent value is returned. There is a single class
    instance for each controller and the mapping of ports to hardware buttons
    depends on the code in the Driver Station.
    """
    class Axis():
        """
        Members:

          kLeftX

          kRightX

          kLeftY

          kRightY

          kLeftTrigger

          kRightTrigger
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kLeftX': <Axis.kLeftX: 0>, 'kRightX': <Axis.kRightX: 4>, 'kLeftY': <Axis.kLeftY: 1>, 'kRightY': <Axis.kRightY: 5>, 'kLeftTrigger': <Axis.kLeftTrigger: 2>, 'kRightTrigger': <Axis.kRightTrigger: 3>}
        kLeftTrigger: wpilib._wpilib.XboxController.Axis # value = <Axis.kLeftTrigger: 2>
        kLeftX: wpilib._wpilib.XboxController.Axis # value = <Axis.kLeftX: 0>
        kLeftY: wpilib._wpilib.XboxController.Axis # value = <Axis.kLeftY: 1>
        kRightTrigger: wpilib._wpilib.XboxController.Axis # value = <Axis.kRightTrigger: 3>
        kRightX: wpilib._wpilib.XboxController.Axis # value = <Axis.kRightX: 4>
        kRightY: wpilib._wpilib.XboxController.Axis # value = <Axis.kRightY: 5>
        pass
    class Button():
        """
        Members:

          kBumperLeft

          kBumperRight

          kStickLeft

          kStickRight

          kA

          kB

          kX

          kY

          kBack

          kStart
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict # value = {'kBumperLeft': <Button.kBumperLeft: 5>, 'kBumperRight': <Button.kBumperRight: 6>, 'kStickLeft': <Button.kStickLeft: 9>, 'kStickRight': <Button.kStickRight: 10>, 'kA': <Button.kA: 1>, 'kB': <Button.kB: 2>, 'kX': <Button.kX: 3>, 'kY': <Button.kY: 4>, 'kBack': <Button.kBack: 7>, 'kStart': <Button.kStart: 8>}
        kA: wpilib._wpilib.XboxController.Button # value = <Button.kA: 1>
        kB: wpilib._wpilib.XboxController.Button # value = <Button.kB: 2>
        kBack: wpilib._wpilib.XboxController.Button # value = <Button.kBack: 7>
        kBumperLeft: wpilib._wpilib.XboxController.Button # value = <Button.kBumperLeft: 5>
        kBumperRight: wpilib._wpilib.XboxController.Button # value = <Button.kBumperRight: 6>
        kStart: wpilib._wpilib.XboxController.Button # value = <Button.kStart: 8>
        kStickLeft: wpilib._wpilib.XboxController.Button # value = <Button.kStickLeft: 9>
        kStickRight: wpilib._wpilib.XboxController.Button # value = <Button.kStickRight: 10>
        kX: wpilib._wpilib.XboxController.Button # value = <Button.kX: 3>
        kY: wpilib._wpilib.XboxController.Button # value = <Button.kY: 4>
        pass
    def __init__(self, port: int) -> None: 
        """
        Construct an instance of an Xbox controller.

        The controller index is the USB port on the Driver Station.

        :param port: The port on the Driver Station that the controller is plugged
                     into (0-5).
        """
    def getAButton(self) -> bool: 
        """
        Read the value of the A button on the controller.

        :returns: The state of the button.
        """
    def getAButtonPressed(self) -> bool: 
        """
        Whether the A button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getAButtonReleased(self) -> bool: 
        """
        Whether the A button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getBButton(self) -> bool: 
        """
        Read the value of the B button on the controller.

        :returns: The state of the button.
        """
    def getBButtonPressed(self) -> bool: 
        """
        Whether the B button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getBButtonReleased(self) -> bool: 
        """
        Whether the B button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getBackButton(self) -> bool: 
        """
        Whether the Y button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getBackButtonPressed(self) -> bool: 
        """
        Whether the back button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getBackButtonReleased(self) -> bool: 
        """
        Whether the back button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getBumper(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Read the value of the bumper button on the controller.

        :param hand: Side of controller whose value should be returned.
        """
    def getBumperPressed(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Whether the bumper was pressed since the last check.

        :param hand: Side of controller whose value should be returned.

        :returns: Whether the button was pressed since the last check.
        """
    def getBumperReleased(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Whether the bumper was released since the last check.

        :param hand: Side of controller whose value should be returned.

        :returns: Whether the button was released since the last check.
        """
    def getStartButton(self) -> bool: 
        """
        Read the value of the start button on the controller.

        :param hand: Side of controller whose value should be returned.

        :returns: The state of the button.
        """
    def getStartButtonPressed(self) -> bool: 
        """
        Whether the start button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getStartButtonReleased(self) -> bool: 
        """
        Whether the start button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getStickButton(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Read the value of the stick button on the controller.

        :param hand: Side of controller whose value should be returned.

        :returns: The state of the button.
        """
    def getStickButtonPressed(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Whether the stick button was pressed since the last check.

        :param hand: Side of controller whose value should be returned.

        :returns: Whether the button was pressed since the last check.
        """
    def getStickButtonReleased(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> bool: 
        """
        Whether the stick button was released since the last check.

        :param hand: Side of controller whose value should be returned.

        :returns: Whether the button was released since the last check.
        """
    def getTriggerAxis(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> float: 
        """
        Get the trigger axis value of the controller.

        :param hand: Side of controller whose value should be returned.
        """
    def getX(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> float: 
        """
        Get the X axis value of the controller.

        :param hand: Side of controller whose value should be returned.
        """
    def getXButton(self) -> bool: 
        """
        Read the value of the X button on the controller.

        :returns: The state of the button.
        """
    def getXButtonPressed(self) -> bool: 
        """
        Whether the X button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getXButtonReleased(self) -> bool: 
        """
        Whether the X button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    def getY(self, hand: wpilib.interfaces._interfaces.GenericHID.Hand) -> float: 
        """
        Get the Y axis value of the controller.

        :param hand: Side of controller whose value should be returned.
        """
    def getYButton(self) -> bool: 
        """
        Read the value of the Y button on the controller.

        :returns: The state of the button.
        """
    def getYButtonPressed(self) -> bool: 
        """
        Whether the Y button was pressed since the last check.

        :returns: Whether the button was pressed since the last check.
        """
    def getYButtonReleased(self) -> bool: 
        """
        Whether the Y button was released since the last check.

        :returns: Whether the button was released since the last check.
        """
    pass
def getCurrentThreadPriority() -> typing.Tuple[int, bool]:
    """
    Get the thread priority for the current thread

    :param isRealTime: Set to true if thread is real-time, otherwise false.

    :returns: The current thread priority. For real-time, this is 1-99
              with 99 being highest. For non-real-time, this is 0. See
              "man 7 sched" for details.
    """
def getTime() -> seconds:
    """
    Gives real-time clock system time with nanosecond resolution

    :returns: The time, just in case you want the robot to start autonomous at 8pm
              on Saturday.
    """
def setCurrentThreadPriority(realTime: bool, priority: int) -> bool:
    """
    Sets the thread priority for the current thread

    :param realTime: Set to true to set a real-time priority, false for standard
                     priority.
    :param priority: Priority to set the thread to. For real-time, this is 1-99
                     with 99 being highest. For non-real-time, this is forced to
                     0. See "man 7 sched" for more details.

    :returns: True on success.
    """
def wait(seconds: seconds) -> None:
    """
    Pause the task for a specified time.

    Pause the execution of the program for a specified period of time given in
    seconds. Motors will continue to run at their last assigned values, and
    sensors will continue to update. Only the task containing the wait will pause
    until the wait time is expired.

    :param seconds: Length of time to pause, in seconds.
    """
def wpi_error_s_AnalogTriggerLimitOrderError() -> str:
    pass
def wpi_error_s_AnalogTriggerPulseOutputError() -> str:
    pass
def wpi_error_s_BadJoystickAxis() -> str:
    pass
def wpi_error_s_BadJoystickIndex() -> str:
    pass
def wpi_error_s_CameraServerError() -> str:
    pass
def wpi_error_s_ChannelIndexOutOfRange() -> str:
    pass
def wpi_error_s_CommandIllegalUse() -> str:
    pass
def wpi_error_s_CompassManufacturerError() -> str:
    pass
def wpi_error_s_CompassTypeError() -> str:
    pass
def wpi_error_s_CompressorAlreadyDefined() -> str:
    pass
def wpi_error_s_CompressorNonMatching() -> str:
    pass
def wpi_error_s_CompressorTaskError() -> str:
    pass
def wpi_error_s_CompressorUndefined() -> str:
    pass
def wpi_error_s_DashboardDataCollision() -> str:
    pass
def wpi_error_s_DashboardDataOverflow() -> str:
    pass
def wpi_error_s_DriveUninitialized() -> str:
    pass
def wpi_error_s_DriverStationTaskError() -> str:
    pass
def wpi_error_s_EnhancedIOMissing() -> str:
    pass
def wpi_error_s_EnhancedIOPWMPeriodOutOfRange() -> str:
    pass
def wpi_error_s_IncompatibleMode() -> str:
    pass
def wpi_error_s_IncompatibleState() -> str:
    pass
def wpi_error_s_InconsistentArrayValueAdded() -> str:
    pass
def wpi_error_s_IncorrectBatteryChannel() -> str:
    pass
def wpi_error_s_InvalidMotorIndex() -> str:
    pass
def wpi_error_s_InvalidParameter() -> str:
    pass
def wpi_error_s_JaguarMessageNotFound() -> str:
    pass
def wpi_error_s_JaguarVersionError() -> str:
    pass
def wpi_error_s_LineNotOutput() -> str:
    pass
def wpi_error_s_LoopTimingError() -> str:
    pass
def wpi_error_s_MismatchedComplexTypeClose() -> str:
    pass
def wpi_error_s_ModuleIndexOutOfRange() -> str:
    pass
def wpi_error_s_NetworkTablesBufferFull() -> str:
    pass
def wpi_error_s_NetworkTablesCorrupt() -> str:
    pass
def wpi_error_s_NetworkTablesReadError() -> str:
    pass
def wpi_error_s_NetworkTablesWrongType() -> str:
    pass
def wpi_error_s_NoAvailableResources() -> str:
    pass
def wpi_error_s_NonBinaryDigitalValue() -> str:
    pass
def wpi_error_s_NotAllocated() -> str:
    pass
def wpi_error_s_NullParameter() -> str:
    pass
def wpi_error_s_ParameterOutOfRange() -> str:
    pass
def wpi_error_s_ResourceAlreadyAllocated() -> str:
    pass
def wpi_error_s_SPIClockRateTooLow() -> str:
    pass
def wpi_error_s_SPIReadNoData() -> str:
    pass
def wpi_error_s_SPIReadNoMISO() -> str:
    pass
def wpi_error_s_SPIWriteNoMOSI() -> str:
    pass
def wpi_error_s_SampleRateTooHigh() -> str:
    pass
def wpi_error_s_SmartDashboardMissingKey() -> str:
    pass
def wpi_error_s_TaskDeletedError() -> str:
    pass
def wpi_error_s_TaskError() -> str:
    pass
def wpi_error_s_TaskIDError() -> str:
    pass
def wpi_error_s_TaskMemoryError() -> str:
    pass
def wpi_error_s_TaskOptionsError() -> str:
    pass
def wpi_error_s_TaskPriorityError() -> str:
    pass
def wpi_error_s_Timeout() -> str:
    pass
def wpi_error_s_UnsupportedInSimulation() -> str:
    pass
def wpi_error_s_VoltageOutOfRange() -> str:
    pass
def wpi_error_value_AnalogTriggerLimitOrderError() -> int:
    pass
def wpi_error_value_AnalogTriggerPulseOutputError() -> int:
    pass
def wpi_error_value_BadJoystickAxis() -> int:
    pass
def wpi_error_value_BadJoystickIndex() -> int:
    pass
def wpi_error_value_CameraServerError() -> int:
    pass
def wpi_error_value_ChannelIndexOutOfRange() -> int:
    pass
def wpi_error_value_CommandIllegalUse() -> int:
    pass
def wpi_error_value_CompassManufacturerError() -> int:
    pass
def wpi_error_value_CompassTypeError() -> int:
    pass
def wpi_error_value_CompressorAlreadyDefined() -> int:
    pass
def wpi_error_value_CompressorNonMatching() -> int:
    pass
def wpi_error_value_CompressorTaskError() -> int:
    pass
def wpi_error_value_CompressorUndefined() -> int:
    pass
def wpi_error_value_DashboardDataCollision() -> int:
    pass
def wpi_error_value_DashboardDataOverflow() -> int:
    pass
def wpi_error_value_DriveUninitialized() -> int:
    pass
def wpi_error_value_DriverStationTaskError() -> int:
    pass
def wpi_error_value_EnhancedIOMissing() -> int:
    pass
def wpi_error_value_EnhancedIOPWMPeriodOutOfRange() -> int:
    pass
def wpi_error_value_IncompatibleMode() -> int:
    pass
def wpi_error_value_IncompatibleState() -> int:
    pass
def wpi_error_value_InconsistentArrayValueAdded() -> int:
    pass
def wpi_error_value_IncorrectBatteryChannel() -> int:
    pass
def wpi_error_value_InvalidMotorIndex() -> int:
    pass
def wpi_error_value_InvalidParameter() -> int:
    pass
def wpi_error_value_JaguarMessageNotFound() -> int:
    pass
def wpi_error_value_JaguarVersionError() -> int:
    pass
def wpi_error_value_LineNotOutput() -> int:
    pass
def wpi_error_value_LoopTimingError() -> int:
    pass
def wpi_error_value_MismatchedComplexTypeClose() -> int:
    pass
def wpi_error_value_ModuleIndexOutOfRange() -> int:
    pass
def wpi_error_value_NetworkTablesBufferFull() -> int:
    pass
def wpi_error_value_NetworkTablesCorrupt() -> int:
    pass
def wpi_error_value_NetworkTablesReadError() -> int:
    pass
def wpi_error_value_NetworkTablesWrongType() -> int:
    pass
def wpi_error_value_NoAvailableResources() -> int:
    pass
def wpi_error_value_NonBinaryDigitalValue() -> int:
    pass
def wpi_error_value_NotAllocated() -> int:
    pass
def wpi_error_value_NullParameter() -> int:
    pass
def wpi_error_value_ParameterOutOfRange() -> int:
    pass
def wpi_error_value_ResourceAlreadyAllocated() -> int:
    pass
def wpi_error_value_SPIClockRateTooLow() -> int:
    pass
def wpi_error_value_SPIReadNoData() -> int:
    pass
def wpi_error_value_SPIReadNoMISO() -> int:
    pass
def wpi_error_value_SPIWriteNoMOSI() -> int:
    pass
def wpi_error_value_SampleRateTooHigh() -> int:
    pass
def wpi_error_value_SmartDashboardMissingKey() -> int:
    pass
def wpi_error_value_TaskDeletedError() -> int:
    pass
def wpi_error_value_TaskError() -> int:
    pass
def wpi_error_value_TaskIDError() -> int:
    pass
def wpi_error_value_TaskMemoryError() -> int:
    pass
def wpi_error_value_TaskOptionsError() -> int:
    pass
def wpi_error_value_TaskPriorityError() -> int:
    pass
def wpi_error_value_Timeout() -> int:
    pass
def wpi_error_value_UnsupportedInSimulation() -> int:
    pass
def wpi_error_value_VoltageOutOfRange() -> int:
    pass
_sd_cleanup: PyCapsule # value = <capsule object NULL>
