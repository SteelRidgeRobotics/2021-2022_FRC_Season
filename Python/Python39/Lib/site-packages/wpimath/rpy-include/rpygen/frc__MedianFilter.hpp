
 

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>


#include <..\_impl\include\frc\MedianFilter.h>





namespace rpygen {

using namespace frc;


template <typename T>
struct bind_frc__MedianFilter {

    

    py::class_<typename frc::MedianFilter<T>, std::shared_ptr<typename frc::MedianFilter<T>>> cls_MedianFilter;




    py::module &m;
    std::string clsName;

bind_frc__MedianFilter(py::module &m, const char * clsName) :
    cls_MedianFilter(m, clsName),



    m(m),
    clsName(clsName)
{}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    
  cls_MedianFilter.doc() =
    "A class that implements a moving-window median filter.  Useful for reducing\n"
"measurement noise, especially with processes that generate occasional,\n"
"extreme outliers (such as values from vision processing, LIDAR, or ultrasonic\n"
"sensors).";

  cls_MedianFilter
      .def(py::init<size_t>(),
      py::arg("size"), release_gil(), py::doc(
    "Creates a new MedianFilter.\n"
"\n"
":param size: The number of samples in the moving window.")
  )
    
      .def("calculate", &frc::MedianFilter<T>::Calculate,
      py::arg("next"), release_gil(), py::doc(
    "Calculates the moving-window median for the next value of the input stream.\n"
"\n"
":param next: The next input value.\n"
"\n"
":returns: The median of the moving window, updated to include the next value.")
  )
    
      .def("reset", &frc::MedianFilter<T>::Reset, release_gil(), py::doc(
    "Resets the filter, clearing the window of all elements.")
  )
    
;

  

    if (set_doc) {
        cls_MedianFilter.doc() = set_doc;
    }
    if (add_doc) {
        cls_MedianFilter.doc() = py::cast<std::string>(cls_MedianFilter.doc()) + add_doc;
    }

    
}

}; // struct bind_frc__MedianFilter

}; // namespace rpygen